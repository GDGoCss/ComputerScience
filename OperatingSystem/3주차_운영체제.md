## 1. 프로세스와 스레드

**프로그램**: 저장장치에 저장되어 있는 정적인 상태(레시피)
**프로세스**: 실행을 위해 메모리에 올라온 동적인 상태(요리)

### 1.1. 프로그램에서 프로세스로의 전환
**프로세스 제어 블록(PCB)**
- 프로세스를 실행하는 데 필요한 중요한 정보를 보관하는 자료구조
- 프로세스는 고유의 프로세스 제어 블록을 가짐
- 프로세스 생성 시 만들어져 프로세스가 실행을 완료하면 폐기
  
`프로세스 = 프로그램 + 프로세스 제어 블록`

`프로그램 = 프로세스 – 프로세스 제어 블록`

### 1.2. 프로세스의 다섯 가지 상태
- 생성 상태: 프로그램이 메모리에 올라오고 운영체제로부터 PCB를 할당받은 상태
- 준비 상태: 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
- 실행 상태: 준비 상태에 있는 프로세스 중 하나가 선택되고, 선택된 프로세스가 타임 슬라이스를 얻어 CPU를 사용하는 상태. 작업을 마치면 완료 상태, 작업을 끝내지 못하면 준비 상태로 돌아감

`타임 슬라이스`: 하나의 프로세스에 할당되는 짧은 시간 단위
- 대기 상태: 실행 상태의 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태. 입출력이 완료되면 준비 상태로 이동
- 완료 상태: 프로세스가 종료된 상태. 사용하던 모든 자원은 반납되고 메모리에서 지워지며 PCB 폐기

### 1.3. 문맥 교환
: CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업
- 타임 슬라이스를 매우 작은 값으로 설정하면 여러 프로그램이 동시에 실행되는 것처럼 느껴짐
- 타임 슬라이스를 큰 값으로 설정하면 시스템이 느리게 반응하는 것처럼 느껴짐
- 적절한 타임 슬라이스 크기 설정 중요
- 타임 슬라이스가 작으면
    - 문맥 교환을 하는 동안 실제 프로세스의 작업을 처리할 수 없음
    - 타임 슬라이스의 값이 작으면 그만큼 문맥 교환이 잦아짐
    - 실제 작업을 처리하는 시간보다 문맥 교환에 소모되는 시간이 커짐
- 타임 슬라이스가 크면
    - 다른 작업을 요청해도(키보드 입력, 마우스 클릭 등) 시스템이 즉시 반응하지 못하고 멈춘 것처럼 보임
    - 다른 프로세스들이 실행 차례가 올 때까지 오래 기다려야 함
- 타임 슬라이스의 값은 문맥 교환과 시스템 반응성 사이의 균형을 맞추는 것이 중요

### 1.4. `fork()` 함수와 `exec()` 함수
`fork()` 함수: 프로세스 복제
- 현재 실행 중인 프로세스의 완전한 복사본을 만들어 새로운 자식 프로세스를 생성
- 기존 프로세스의 메모리 공간, 레지스터 상태 등 모든 자원을 그대로 복제
- `fork()`가 호출되면 부모와 자식 프로세스 모두 `fork()` 다음 라인부터 코드를 실행
- 부모 프로세스: 자식 프로세스의 PID(프로세스 ID)를 반환
- 자식 프로세스: 0을 반환
- 이러한 반환 값 차이를 이용해 부모와 자식 프로세스가 서로 다른 코드를 실행하도록 분기 처리 가능
- 프로세스의 생성 속도가 빠르며 추가 작업 없이 자원 상속 가능

`exec()` 함수: 새로운 프로그램 실행
- `fork()`로 생성된 자식 프로세스에서 새로운 프로그램을 실행
- 현재 프로세스의 메모리 공간을 완전히 덮어쓰고, 새로운 프로그램의 코드로 채움
- `exec()`는 새로운 프로세스를 생성하는 것이 아니라, 기존 프로세스의 구조를 재활용하여 새로운 프로그램으로 교체하는 역할

### 1.5. 스레드
: 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위
- 운영체제 입장의 작업 단위: 프로세스
- CPU 입장의 작업 단위: 스레드

#### 1.5.1. 스레드 관련 용어
- 멀티스레드: 프로세스 내 작업을 여러 개의 스레드로 분할함으로써 작업의 부담을 줄이는 프로세스 운영 기법
- 멀티태스킹: 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법
- 멀티 프로세싱: 여러 CPU를 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경
- CPU 멀티스레드: 한 번에 하나씩 처리해야 하는 스레드를 잘게 쪼개어 동시에 처리하는 명령어 병렬 처리 기법

#### 1.5.2. 멀티스레드
- 장점: 응답성 향상, 자원 공유, 효율성 향상, 다중 CPU 지원, 문맥교환 비용 감소
- 단점: 동기화 문제, 디버깅 어려움, 설계 복잡성, 전체 영향 가능성 존재
- 멀티스레드 모델 종류
    - N:1 모델: [여러 사용자 스레드] : [하나의 커널 스레드]
    -> 구현 간단. 커널 전환 없음. 병렬 처리 불가. 하나가 블로킹되면 전체 멈춤
    - 1:1 모델: [하나의 사용자 스레드] : [하나의 커널 스레드]
    ->병렬 처리 가능. 자원 소모 큼. 대부분의 현대 OS 사용(Linux pthreads)
    - M:N 모델: [M개의 사용자 스레드] : [N개의 커널 스레드]
    -> 구현 복잡. 유연하고 확장성 좋음. 일부 Unix 시스템과 Windows에서 사용


## 2. CPU 스케줄링

### 2.1. 스케줄링
: 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 배정할지 결정하는 일

**스케줄링의 목적**
- 공평성
- 효율성
- 안전성
- 확장성
- 반응 시간 보장
- 무한 연기 방지

### 2.2. 선점형 스케줄링과 비선점형 스케줄링
- 선점형 스케줄링
: 어떤 프로세스가 CPU를 할당받아 실행중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식. 실행 상태에 있는 작업을 중단시키고 새로운 작업을 실행 가능

`ex. 라운드 로빈(RR), SRT, 다단계 큐`

- 비선점형 스케줄링
: 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식. 실행 상태에 있는 작업이 완료될 때까지 다른 작업 불가능

`ex. FCFS, SJF, HRN`

`반환 시간`: `종료 시간` - `도착 시간`

`대기 시간`: `반환 시간` - `실행 시간`

### 2.3. FCFS
: 선입선출
| 프로세스 | 도착 시간 | 실행 시간 |
| :---: | :---: | :---: |
| P1 | 0 | 30 |
| P2 | 3 | 18 |
| P3 | 6 | 9 |

실행 결과: `P1(30)` - `P2(18)` - `P3(9)`

| 프로세스 | 도착 시간 | 실행 시간 | 종료 시간 | 반환 시간 | 대기 시간 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| P1 | 0 | 30 | 30 | 30 | 0 |
| P2 | 3 | 18 | 48 | 45 | 27 |
| P3 | 6 | 9 | 57 | 51 | 42 |

### 2.4. SJF
: 준비 큐에 있는 프로세스 중 실행 시간이 가장 짧은 작업부터 CPU 할당
| 프로세스 | 도착 시간 | 실행 시간 |
| :---: | :---: | :---: |
| P1 | 0 | 30 |
| P2 | 3 | 18 |
| P3 | 6 | 9 |

실행 결과: `P1(30)` - `P3(9)` - `P2(18)`

| 프로세스 | 도착 시간 | 실행 시간 | 종료 시간 | 반환 시간 | 대기 시간 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| P1 | 0 | 30 | 30 | 30 | 0 |
| P2 | 3 | 18 | 57 | 54 | 36 |
| P3 | 6 | 9 | 39 | 33 | 24 |

### 2.5. HRN
: 우선순위를 결정하여 CPU 할당

`우선순위` = `(대기 시간 + 실행 시간)` / `실행 시간`
| 프로세스 | 도착 시간 | 실행 시간 |
| :---: | :---: | :---: |
| P1 | 0 | 30 |
| P2 | 3 | 18 |
| P3 | 6 | 9 |

실행 결과: `P1(30)` - `P3(9)` - `P2(18)`
- 우선순위: P2 = `(27 + 18) / 18 = 2.5`, P3 = `(24 + 9) / 9 = 3.67`

| 프로세스 | 도착 시간 | 실행 시간 | 종료 시간 | 반환 시간 | 대기 시간 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| P1 | 0 | 30 | 30 | 30 | 0 |
| P2 | 3 | 18 | 57 | 54 | 36 |
| P3 | 6 | 9 | 39 | 33 | 24 |

### 2.6. 라운드 로빈(RR)
: 타임 슬라이스 동안 작업

타임 슬라이스: 10
| 프로세스 | 도착 시간 | 실행 시간 |
| :---: | :---: | :---: |
| P1 | 0 | 30 |
| P2 | 3 | 18 |
| P3 | 6 | 9 |

실행 결과: `P1(10)` - `P2(10)` - `P3(9)` - `P1(10)` - `P2(8)` - `P1(10)`

| 프로세스 | 도착 시간 | 실행 시간 | 종료 시간 | 반환 시간 | 대기 시간 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| P1 | 0 | 30 | 57 | 57 | 27 |
| P2 | 3 | 18 | 47 | 44 | 26 |
| P3 | 6 | 9 | 29 | 23 | 14 |

### 2.7. SRT
: SJF + 라운드 로빈(RR)

타임 슬라이스: 10
| 프로세스 | 도착 시간 | 실행 시간 |
| :---: | :---: | :---: |
| P1 | 0 | 30 |
| P2 | 3 | 18 |
| P3 | 6 | 9 |

실행 결과: `P1(10)` - `P3(9)` - `P2(10)` - `P2(8)` - `P1(10)` - `P1(10)`

| 프로세스 | 도착 시간 | 실행 시간 | 종료 시간 | 반환 시간 | 대기 시간 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| P1 | 0 | 30 | 57 | 57 | 27 |
| P2 | 3 | 18 | 37 | 34 | 16 |
| P3 | 6 | 9 | 19 | 13 | 4 |


## 3. 가상 메모리 관리

### 3.1. 요구 페이징
- 요구 페이징
: 사용자가 요구할 때 해당 페이지를 메모리로 가져오는 것
- 프로세스의 일부만 메모리로 가져오는 이유

-> 메모리의 효율적 관리, 응답 속도 향상
- 미리 가져오기: 요구 페이징과 반대되는 개념 ex. 캐시
- 페이지 부재(page fault)
: 프로세스가 페이지를 요청했을 때 해당 페이지가 메모리에 없는 상황

### 3.2. 페이지 교체 알고리즘
**간단한 알고리즘**
- 무작위 페이지 교체: 특별한 로직 없이 무작위로 선정
- FIFO(First In First Out): 선입선출

**이론적 알고리즘**
- 최적 페이지 교체: 미래의 메모리 접근 패턴을 보고 대상 페이지를 선정. 구현 불가능

**최적 근접 알고리즘**
- LRU(Least Recently Used): 최근 최소 사용 페이지 교체
- LFU(Least Frequency Used): 최소 빈도 사용 페이지 교체
- NUR(Not Used Recently): 최근 미사용 페이지 교체
- FIFO 변형: 2차 기회 페이지 교체. 페이지 부재 없이 성공할 경우 페이지를 큐의 맨 뒤로 이동

#### 3.2.1. FIFO
예시: 페이지 프레임 3개, 참조 페이지 [1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5]
| 참조 페이지 | 1 | 2 | 3 | 4 | 1 | 2 | 5 | 1 | 2 | 3 | 4 | 5 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| 프레임 1 | 1 | 1 | 1 | 4 | 4 | 4 | 5 | 5 | 5 | 3 | 3 | 3 |
| 프레임 2 | | 2 | 2 | 2 | 1 | 1 | 1 | 1 | 1 | 1 | 4 | 4 |
| 프레임 3 | | | 3 | 3 | 3 | 2 | 2 | 2 | 2 | 2 | 2 | 5 |
| 페이지 부재 | ✔️ | ✔️ | ✔️ | ✔️ | ✔️ | ✔️ | ✔️ | ❌ | ❌ | ✔️ | ✔️ | ✔️ |

결과: 총 10번의 페이지 부재 발생.

#### 3.2.2. LRU
예시: 페이지 프레임 3개, 참조 페이지 [1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5]
| 참조 페이지 | 1 | 2 | 3 | 4 | 1 | 2 | 5 | 1 | 2 | 3 | 4 | 5 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| 프레임 1 | 1 | 1 | 1 | 4 | 4 | 4 | 5 | 5 | 5 | 3 | 3 | 3 |
| 프레임 2 | | 2 | 2 | 2 | 1 | 1 | 1 | 1 | 1 | 1 | 4 | 4 |
| 프레임 3 | | | 3 | 3 | 3 | 2 | 2 | 2 | 2 | 2 | 2 | 5 |
| 페이지 부재 | ✔️ | ✔️ | ✔️ | ✔️ | ✔️ | ✔️ | ✔️ | ❌ | ❌ | ✔️ | ✔️ | ✔️ |

결과: 총 10번의 페이지 부재 발생.

#### 3.2.3. LFU
예시: 페이지 프레임 3개, 참조 페이지 [1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5]
| 참조 페이지 | 1 | 2 | 3 | 4 | 1 | 2 | 5 | 1 | 2 | 3 | 4 | 5 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| 프레임 1 | 1(1) | 1(1) | 1(1) | 4(1) | 4(1) | 4(1) | 5(1) | 5(1) | 5(1) | 3(2) | 4(2) | 5(2) |
| 프레임 2 | | 2(1) | 2(1) | 2(1) | 1(2) | 1(2) | 1(2) | 1(3) | 1(3) | 1(3) | 1(3) | 1(3) |
| 프레임 3 | | | 3(1) | 3(1) | 3(1) | 2(2) | 2(2) | 2(2) | 2(3) | 2(3) | 2(3) | 2(3) |
| 페이지 부재 | ✔️ | ✔️ | ✔️ | ✔️ | ✔️ | ✔️ | ✔️ | ❌ | ❌ | ✔️ | ✔️ | ✔️ |

결과: 총 10번의 페이지 폴트 발생.

`() 안의 숫자는 참조 횟수를 의미하며, 참조 횟수가 같을 경우 FIFO 원칙을 따름`


## 4. 파일 시스템

### 4.1. 파일과 파일 시스템
- 파일 시스템: 파일을 보관하고 관리하는 파일 관리자를 두어 저장장치의 전체 관리를 맡기는 것
- 파일 디스크립터: 운영체제가 파일을 관리하기 위해 할당하는 정수값
- 디렉터리: 파일의 집합체(윈도우의 폴더)
- 블록: 저장장치에서 파일을 일정 크기로 묶어서 관리. 물리적인 저장 공간의 최소 단위
- 메모리의 단위는 바이트, 저장장치의 단위는 블록

**파일의 종류**

- 실행 파일: 운영체제가 메모리로 가져와 CPU를 이용하여 작업하는 파일
- 데이터 파일: 실행 파일이 작업하는 데 필요한 데이터를 모아놓은 파일
- 파일 작업: 파일을 지우거나 파일을 변경하는 일

**저장장치 관리 기법**

- 파티션: 디스크를 논리적으로 분할하는 작업
- 파티셔닝: 저장장치를 2개 이상의 묶음으로 나누는 것
- 마운트: 유닉스에서 여러 개의 파티션을 하나로 통합하는 기능
- 포맷: 저장장치의 파일 시스템을 초기화하는 작업
- 빠른 포맷: 데이터는 그대로 둔 채 파일 테이블만 초기화
- 느린 포맷: 파일 테이블 초기화 및 블록의 모든 데이터를 0으로 만듦
- 조각 모음: 단편화 현상을 해결하기 위해 흩어진 블록들을 모아 연속된 공간으로 만드는 작업

### 4.2. 파일 구조
**순차 파일 구조**

- 파일 내용이 하나의 긴 줄로 늘어선 형태
- 장점
    - 모든 데이터 순서대로 기록되어 저장 공간에 낭비되는 부분이 없음
    - 구조가 단순하여 메모리를 이용한 저장장치에 적용 가능
    - 순서대로 데이터를 읽거나 저장할 때 매우 빠르게 처리
- 단점
    - 새로운 데이터를 삽입하거나 삭제할 때 시간이 많이 걸림
    - 특정 데이터에 직접 접근이 어려움

**인덱스 파일 구조**

- 순차 파일 구조에 인덱스 테이블을 추가하여 순차 접근과 직접 접근이 가능
- 인덱스 테이블을 여러 개 만들면 다양한 접근 가능

**직접 파일 구조**
- 저장하려는 데이터의 특정 값에 어떤 관계를 정의하여 물리적인 주소로 바로 변환하는 파일 구조
- 해시 함수를 이용하여 주소를 변환하기 때문에 데이터 접근이 매우 빠름
- 데이터가 고르게 저장될 수 있는 해시 함수를 찾기 쉽지 않음

### 4.3. 디렉터리의 구조
**디렉터리의 개념**

- 루트 디렉터리(/): 최상위에 있는 디렉터리
- 마침표 파일(.): 자기 자신의 디렉터리
- 2개 마침표 파일(..): 상위 디렉터리

#### 4.3.1. **디스크 파일 할당**
**연속 할당**
- 파일을 구성하는 데이터를 디스크상에 연속적으로 배열하는 간단한 방식
- 빠른 입출력 작업 가능
- 직접 접근 가능
- 외부 조각이 생길 수 있음

**불연속 할당**

- 비어 있는 블록에 데이터를 분산하여 저장하고 파일 시스템이 정보를 관리하는 방식 ex. 연결 할당, 인덱스 할당
- **연결 할당(체인 할당)**
    - 파일에 속한 데이터를 연결 리스트로 관리하는 방식. 끝은 –1로 표시
    - 외부 조각 문제 방지
    - 직접 접근 불가능, 신뢰성 문제 존재
    - 디스크 용량이 테이블의 주소 크기로 제한
- **인덱스 할당**
    - 데이터의 인덱스를 담고 있는 인덱스 블록을 연결
    - 직접 접근 가능, 외부 조각 문제 방지
    - 아무리 작은 조각이어도 블록 2개 필요(인덱스를 위한 블록, 실제 데이터를 위한 블록)
    - 너무 작으면 공간 낭비
    - 큰 파일의 경우 인덱스 블록으로 위치를 다 표현할 수 없음
