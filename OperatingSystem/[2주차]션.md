# CSS 스터디 [3주차] 운영체제

# 운영체제 구조

- 인터페이스 (GUI, CUI) : 사용자(사람)가 운영체제와 상호작용할 수 있도록 도움.
- 시스템콜 : 커널을 필요로하는 작업을 수행하기 위해 호출되는 인터페이스.
- 커널 : 프로세스-스레드 관리, 메모리 관리, I/O 디바이스 연결 제어, 동시 접근 관리.
- 드라이버 : I/O 디바이스 하드웨어와 컴퓨터 소프트웨어가 연결될 수 있도록 돕는 인터페이스.

---

# 프로세스, 스레드

## 프로세스

프로그램이 실행될 시, 프로세스 형태로 메모리에 할당된다.

프로세스는 메모리에서 동적 영역, 정적 영역으로 분류되며, 크게 네가지로 공간으로 나뉜다.

동적 영역 

- 스택 : 지역변수, 매개변수, 함수 저장. 함수가 재귀적으로 실행되면 크기가 늘어날 수 있어, 스택-힙 메모리 사이에 공간을 비워둠.
- 힙 : 런타임시 크기가 결정됨. 동적 데이터가 할당됨. ex) c++ 벡터

정적 영역

- 데이터 영역 : 전역변수, 정적 변수 등이 저장됨. bss segment( 초기화되지 않은 변수 ), data segment ( 초기화 된 변수 ) 의 영역 등으로 세분화 됨.
- 코드 영역 : 내장된 소스코드가 들어감. cpu가 해석 가능한 기계어 형태로 저장됨.

## 스레드

프로세스가 할당받은 자원을 이용하는 가장 작은 실행 단위. 프로세스는 여러 스레드를 가질 수 있음.

스레드끼리 프로세스의 자원을 공유함.

프로세스의 4가지 영역(스택, 힙, 데이터, 코드) 중, 스택을 제외한 것들을 공유 자원으로 사용함.

---

### 프로세스 상태

- 생성 (create) : 프로세스가 생성된 상태. PCB 할당됨.
- 대기 (ready) : user space 메모리 할당 기다리는 상태, cpu 스케줄러로부터 cpu 할당받기 기다리는 상태.
- 실행 (running) : cpu, 메모리 자원 할당받고 작업 수행되는 상태.
- 중단 (blocked, waiting) : 외부 이벤트 (I/O 요청 등) 종료를 기다리는 상태. pcb에 현재 상태 저장됨.
- 종료 (terminated) : 프로세스 끝난 상태. CPU, 메모리 자원 반납.

### PCB (Process Control Block)

프로세스의 메타데이터가 저장됨.

- 프로세스 상태 : ready, blocked 등등.
- 프로세스 ID, 프로세스 자식 ID
- 레지스터 값 : 프로세스가 중단될 시, 나중에 이어서 할 수 있도록 레지스터 값 저장.
- 프로그램 카운터 : 다음 명령어 주소에 대한 포인터

등등 기록.

---

## 동시성, 병렬성

동시성 : 하나의 코어가 여러 작업을 빠르게 돌아가며 수행. 실제로는 아니지만 동시에 되는 것처럼 보이게 하는 성질.

병렬성 : 실제로 여러 코어를 이용하여 병렬적으로 작업 수행.

## 프로세스 컨텍스트 스위칭

프로세스 컨텍스트 스위칭이 동시성을 만족시킴.

### 스위칭 과정 :

프로세스 전환시, 현제 프로세스의 PCB를 보관 후, 이전에 저장했던 다음 프로세스의 PCB 복구해 활용한다.

---

## CPU 스케줄링

cpu 자원을 어떤 프로세스에게 할당할지 정해줌. 프로세스 우선순위, 작업량 등을 고려하여 배치함.

멀티태스킹을 가능하게 하는데에 있어 핵심적인 부분.

이처럼 할당 순서를 결정하는데에 여러 알고리즘이 존재. ( FCFS, SJF, 라운드로빈, 우선순위 등등)

---

## 멀티 프로세싱, 멀티 스레딩

### 멀티 프로세싱

: 하나의 애플리케이션을 여러 프로세스로 구성하여, 각 프로세스가 각 작업을 수행하도록 함.

장점 : 여러 프로세스 중 하나에 장애가 나도, 다른 것에 영향 확산되지 않음.

단점 : 빈번한 컨텍스트 스위칭으로 인한 오버헤드 발생.

### 멀티 스레딩

: 하나의 애플리케이션을 여러 스레드로 구성하여, 각 스레드가 각 작업 수행하도록 함.

장점 :

- 시스템 자원 소모 감소
- 컨텍스트 스위칭 빠름. 프로세스 내의 대부분의 영역을 공유자원으로 사용하기에, 스위칭 시 stack 영역만 처리하면 됨.

단점 :

- 하나의 스레드에 문제 생기면 프로세스 전체가 영향 받음.
- 동기화 문제 : 공유 자원을 사용하므로, 충돌 발생 가능성 존재.

---

## 동기화, 임계영역

동기화 : 여러 스레드들이 공유 자원에 순차적으로 접근할 수 있도록 제어하는 것.

임계영역 : 멀티스레딩에서 공유자원에 접근하는 코드 영역.

ex  프로세스의 data, heap 영역 등.

경쟁상태 : 공유자원에 두가지 이상의 프로세스(또는 스레드)가 접근하는 상황.

→ 임계영역은 한번에 하나의 스레드만 접근 가능하게 하도록 ‘동기화’ 작업이 필요.

임계영역에서 경쟁상태가 일어나지 않도록 하는 방법들은 다음 세가지 조건을 모두 만족시켜야한다.

- 상호 배제 : 한 프로세스(또는 스레드)가 임계영역에 들어가면 다른 것은 접근하면 안된다.
- 한정 대기 : 어떤 프로세스(또는 스레드)도 임계영역에 못들어가 무한대기 상태가 되면 안된다.
- 융통성 : 한 프로세스(또는 스레드)는 다른 것의 일을 방해하면 안된다.

### 상호배제 만족 못하는 경우 :

![image.png](attachment:a4e0dd54-cd4b-4c4f-a90a-57d575c36638:image.png)

while문 과 lock = true 사이에 다른 스레드의 접근을 막지 못함.

→ 임계영역에 둘 이상이 접근.

### 한정대기 만족 못하는 경우 :

![image.png](attachment:a5a029f5-7eb6-4e59-b746-132a9257c82b:image.png)

while문 접근 전에 둘 모두 lock이 될 시,  무한루프에 빠지게 됨.

### 융통성 만족 못하는 경우 :

![image.png](attachment:ad432a7d-944e-41c3-a7d7-298823fc2545:image.png)

하나의 프로세스가 실행되면 재실행 될 수 없다. 무조건 p2가 수행된 후 lock 값을 바꿔줘야하기 때문.

## 동기화 방법들

아래의 모든 방법들은 락(Lock) 메커니즘을 토대로 함.

락 : 하나가 작업중일 시, 나머지는 접근할 수 없도록 잠금.

피터슨 알고리즘 :

![image.png](attachment:4fcc2294-af32-4a9a-99a4-76517d4c7f07:image.png)

while 전까지 두 프로세스 모두 동시에 실행되더라도, turn 값의 변동으로 인해 둘 중 하나는 무조건 while문에 걸리게 된다.

단점 : 두개의 프로세스를 넘어선 멀티태스킹 환경에선 해당 알고리즘을 일반화하기 어려움. 또한 융통성 조건을 만족시키지 못할 수 있음.

---

### 세마포어 :

![image.png](attachment:2f3444dc-4765-48e2-8afa-2538ba0cbbbe:image.png)

1. 전역변수 `RS`  를 둚. RS는 현재 사용 가능한 자원의 개수.
2. 사용 가능할 시, RS 하나 줄임. 가능한 것 없을시 `block()` 으로 대기상태.
3. 임계영역 종료시 RS 개수 하나 늘리고 `wake_up()` 으로 임계영역 빠져나왔음을 알림.

### 뮤텍스 :

세마포어의 RS를 1개일 때의 것. 원리 동일.

### 모니터 :

직접 자원에 접근하는 세마포어의 경우 잘못 사용될 시 임계영역 보호받지 못할 수 있음

→ 이러한 과정을 내부로 숨기고, 제공된 인터페이스로만으로 동기화를 도움.