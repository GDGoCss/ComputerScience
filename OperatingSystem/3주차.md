# 3주차

## 📋 목차

1. [운영체제 기본 개념](https://www.notion.so/3-27cfaec6a7b780e4b951d2a446382014?pvs=21)
2. [프로세스 & 스레드](https://www.notion.so/3-27cfaec6a7b780e4b951d2a446382014?pvs=21)
3. [CPU 스케줄링](https://www.notion.so/3-27cfaec6a7b780e4b951d2a446382014?pvs=21)
4. [프로세스 동기화](https://www.notion.so/3-27cfaec6a7b780e4b951d2a446382014?pvs=21)
5. [메모리 관리](https://www.notion.so/3-27cfaec6a7b780e4b951d2a446382014?pvs=21)
6. [파일 시스템](https://www.notion.so/3-27cfaec6a7b780e4b951d2a446382014?pvs=21)
7. [최신 기술](https://www.notion.so/3-27cfaec6a7b780e4b951d2a446382014?pvs=21)
8. [면접 핵심 질문](https://www.notion.so/3-27cfaec6a7b780e4b951d2a446382014?pvs=21)

---

## 1. 운영체제 기본 개념

### 운영체제의 역할

- **자원 관리**: CPU, 메모리, I/O 장치 효율적 관리
- **추상화 제공**: 하드웨어 복잡성 숨기고 편리한 인터페이스 제공
- **보안 및 보호**: 프로세스 간 격리, 접근 제어
- **서비스 제공**: 시스템 콜을 통한 OS 서비스 제공

### 시스템 콜 (System Call)

**정의**: 사용자 프로그램이 OS 서비스를 요청하는 인터페이스

**주요 종류**:

- **프로세스 제어**: `fork()`, `exec()`, `wait()`, `exit()`
- **파일 조작**: `open()`, `read()`, `write()`, `close()`
- **통신**: `pipe()`, `shmget()`, `mmap()`

**동작 과정**:

1. 시스템 콜 호출 → 소프트웨어 인터럽트 발생
2. 사용자 모드 → 커널 모드 전환
3. 시스템 콜 처리
4. 커널 모드 → 사용자 모드 복귀

---

## 2. 프로세스 & 스레드

### 프로세스

**정의**: 실행 중인 프로그램

**프로세스 상태**:

- **New**: 생성 중
- **Ready**: CPU 할당 대기
- **Running**: CPU에서 실행 중
- **Waiting**: I/O 완료 대기
- **Terminated**: 실행 완료

### 프로세스 vs 스레드

| 특성 | 프로세스 | 스레드 |
| --- | --- | --- |
| **메모리** | 독립적 주소 공간 | 주소 공간 공유 |
| **생성 비용** | 높음 | 낮음 |
| **통신** | IPC 필요 | 직접 통신 |
| **보안** | 높음 (격리) | 낮음 (공유) |

### 컨텍스트 스위칭

**정의**: CPU 제어권이 다른 프로세스로 넘어가는 과정

**발생 상황**:

- 타이머 인터럽트
- I/O 요청으로 블록
- 높은 우선순위 프로세스 도착

**오버헤드**: PCB 저장/복구, 캐시 무효화

---

## 3. CPU 스케줄링

### 스케줄링 목표

- **CPU 이용률 최대화**
- **처리량(Throughput) 최대화**
- **대기 시간 최소화**
- **응답 시간 최소화**

### 주요 스케줄링 알고리즘

### 1. FCFS (First Come First Served)

- **방식**: 도착 순서대로 처리
- **장점**: 구현 간단, 공정
- **단점**: 콘보이 효과

### 2. SJF (Shortest Job First)

- **방식**: 실행 시간이 짧은 작업 우선
- **장점**: 평균 대기 시간 최소
- **단점**: 기아 현상, 실행 시간 예측 어려움

### 3. Round Robin

- **방식**: 시간 할당량(Time Quantum) 순환
- **장점**: 공정성, 응답 시간 개선
- **단점**: 문맥 교환 오버헤드

### 4. 우선순위 스케줄링

- **방식**: 우선순위가 높은 프로세스 우선
- **문제**: 기아 현상
- **해결**: 에이징(Aging) 기법

### 5. MLFQ (Multi-Level Feedback Queue)

- **방식**: 여러 우선순위 큐 + 동적 우선순위 조정
- **장점**: I/O 집약적 프로세스 우선 처리
- **실제 사용**: 대부분의 현대 OS

---

## 4. 프로세스 동기화

### 임계 구역 문제

**임계 구역**: 공유 자원에 접근하는 코드 영역

**해결 조건**:

1. **상호 배제**: 한 번에 하나의 프로세스만 실행
2. **진행**: 무한 대기 방지
3. **한정 대기**: 유한 시간 내 접근 보장

### 동기화 도구

### 1. 뮤텍스 (Mutex)

```c
acquire() {
    while (!available);  // 바쁜 대기
    available = false;
}
release() {
    available = true;
}

```

### 2. 세마포어 (Semaphore)

```c
wait(S) {
    while (S <= 0);
    S--;
}
signal(S) {
    S++;
}

```

**종류**:

- **이진 세마포어**: 0 또는 1
- **계수 세마포어**: 자원 개수만큼

### 3. 모니터 (Monitor)

- **정의**: 공유 데이터 + 프로시저 + 동기화
- **특징**: 고수준 동기화 구조체
- **조건 변수**: `wait()`, `signal()` 연산

### 교착 상태 (Deadlock)

### 발생 조건 (모두 만족 시 발생)

1. **상호 배제**: 자원을 배타적으로 사용
2. **점유와 대기**: 자원 보유하며 추가 자원 대기
3. **비선점**: 자원을 강제로 빼앗을 수 없음
4. **순환 대기**: 프로세스들이 순환 형태로 대기

### 해결 방법

1. **예방 (Prevention)**: 4가지 조건 중 하나 제거
2. **회피 (Avoidance)**: 은행원 알고리즘
3. **탐지 및 회복**: 교착 상태 발견 후 프로세스 종료

---

## 5. 메모리 관리

### 메모리 계층 구조

```
레지스터 (가장 빠름)
    ↓
L1/L2/L3 캐시
    ↓
주기억장치 (RAM)
    ↓
보조기억장치 (HDD/SSD)

```

### 가상 메모리

**개념**: 물리 메모리보다 큰 가상 주소 공간 제공

**장점**:

- 프로세스 크기 제한 완화
- 메모리 보호
- 메모리 공유 효율성
- 프로그램 로딩 최적화

### 페이징 vs 세그멘테이션

| 특성 | 페이징 | 세그멘테이션 |
| --- | --- | --- |
| **단위** | 고정 크기 페이지 | 가변 크기 세그먼트 |
| **단편화** | 내부 단편화 | 외부 단편화 |
| **장점** | 외부 단편화 해결 | 논리적 구분 명확 |

### 페이지 교체 알고리즘

### 1. FIFO (First In First Out)

- **방식**: 가장 오래된 페이지 교체
- **문제**: 벨라디 이상 현상

### 2. LRU (Least Recently Used)

- **방식**: 가장 오래 사용되지 않은 페이지 교체
- **장점**: 지역성 원리 활용
- **단점**: 구현 복잡, 오버헤드

### 3. 최적 (Optimal)

- **방식**: 미래에 가장 늦게 사용될 페이지 교체
- **특징**: 이론적 최적, 실제 구현 불가

### 4. Clock (Second Chance)

- **방식**: FIFO + 참조 비트
- **장점**: LRU 근사, 실용적

### 스래싱 (Thrashing)

**정의**: 페이지 부재가 빈번하게 발생하여 성능이 급격히 저하되는 현상

**해결방법**:

- 충분한 프레임 할당
- 작업 집합 모델 적용
- 프로세스 수 조정

---

## 6. 파일 시스템

### 파일 할당 방법

1. **연속 할당**: 연속된 블록에 저장
2. **연결 할당**: 링크드 리스트 구조
3. **색인 할당**: 인덱스 블록 사용

### 디스크 스케줄링

1. **FCFS**: 요청 순서대로
2. **SSTF**: 현재 위치에서 가장 가까운 요청
3. **SCAN**: 엘리베이터 알고리즘
4. **C-SCAN**: 순환 SCAN

---

## 7. 최신 기술

### 가상화 (Virtualization)

**하이퍼바이저 종류**:

- **Type 1 (Bare Metal)**: VMware ESXi, Hyper-V
- **Type 2 (Hosted)**: VirtualBox, VMware Workstation

### 컨테이너화

**Docker 특징**:

- OS 수준 가상화
- 가벼운 리소스 사용
- 빠른 시작 시간
- 일관된 환경 제공

### 컨테이너 vs 가상머신

| 특성 | 컨테이너 | 가상머신 |
| --- | --- | --- |
| **격리 수준** | 프로세스 수준 | 하드웨어 수준 |
| **OS** | 호스트 OS 공유 | 독립적 게스트 OS |
| **시작 시간** | 초 단위 | 분 단위 |
| **자원 사용량** | 적음 | 많음 |

### Kubernetes 핵심 구성 요소

- **Pod**: 가장 작은 배포 단위
- **Service**: 네트워크 엔드포인트
- **Deployment**: 애플리케이션 배포 관리
- **ConfigMap/Secret**: 구성 정보 관리

---

## 8. 예상 면접 핵심 질문

### Q1. 프로세스와 스레드의 차이점은?

**A**: 프로세스는 독립적인 메모리 공간을 가진 실행 단위이며, 스레드는 프로세스 내에서 메모리를 공유하는 실행 단위입니다. 스레드는 생성/전환 비용이 낮고 통신이 쉽지만, 동기화 문제가 발생할 수 있습니다.

### Q2. 교착 상태란 무엇이며, 해결 방법은?

**A**: 두 개 이상의 프로세스가 서로의 자원을 무한정 기다리는 상황입니다. 상호배제, 점유와대기, 비선점, 순환대기 4가지 조건이 모두 만족될 때 발생합니다. 해결방법으로는 예방, 회피(은행원 알고리즘), 탐지 및 회복이 있습니다.

### Q3. 가상 메모리의 장점과 페이징 기법은?

**A**: 가상 메모리는 물리 메모리보다 큰 주소 공간 제공, 프로세스 간 보호, 메모리 공유 효율성 등의 장점이 있습니다. 페이징은 고정 크기 페이지로 메모리를 관리하여 외부 단편화를 해결하는 기법입니다.

### Q4. 뮤텍스와 세마포어의 차이점은?

**A**: 뮤텍스는 한 번에 하나의 스레드만 접근 가능한 이진 락이고, 세마포어는 지정된 개수만큼의 스레드가 접근 가능한 카운터 기반 동기화 도구입니다. 뮤텍스는 소유권 개념이 있어 락을 건 스레드만 해제할 수 있습니다.

### Q5. CPU 스케줄링에서 라운드 로빈의 특징은?

**A**: 각 프로세스에게 동일한 시간 할당량을 주고 순환하여 실행하는 선점형 스케줄링입니다. 공정성을 보장하고 응답시간이 좋지만, 문맥교환 오버헤드가 발생하며 타임 슬라이스 크기 설정이 중요합니다.

### Q6. 페이지 교체에서 LRU 알고리즘이란?

**A**: Least Recently Used로 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘입니다. 지역성 원리를 활용하여 실제적으로 좋은 성능을 보이지만, 구현이 복잡하고 시간/공간 오버헤드가 있습니다.

### Q7. 컨텍스트 스위칭이란 무엇인가?

**A**: CPU 제어권이 한 프로세스에서 다른 프로세스로 넘어가는 과정입니다. 현재 프로세스 상태를 PCB에 저장하고, 새로운 프로세스 상태를 복구합니다. 타이머 인터럽트, I/O 블록, 높은 우선순위 프로세스 도착 시 발생합니다.

### Q8. 컨테이너와 가상머신의 차이점은?

**A**: 컨테이너는 OS 커널을 공유하는 프로세스 수준 가상화로 가볍고 빠르며, 가상머신은 독립적인 OS를 가진 하드웨어 수준 가상화로 강한 격리를 제공합니다. 컨테이너는 마이크로서비스에, 가상머신은 완전한 격리가 필요한 환경에 적합합니다.

### Q9. 시스템 콜이 필요한 이유는?

**A**: 보안과 안정성을 위해 사용자 모드에서는 하드웨어에 직접 접근할 수 없기 때문입니다. 시스템 콜을 통해 커널 모드로 전환하여 OS가 제공하는 서비스(파일 I/O, 프로세스 생성 등)를 안전하게 이용할 수 있습니다.