# 6주차

## 데이터베이스 기본 개념

## DB와 DBMS - 뭐가 다를까?

엑셀로 회원 정보 관리하다가 파일이 날아간 적 있나요? 두 명이 동시에 수정하다가 한 명 작업이 증발한 적은요? 그래서 데이터베이스가 필요합니다.

- **데이터베이스(DB)**는 체계적으로 저장된 데이터 모음입니다. 학생 정보, 주문 내역, 게시판 글 같은 거죠.
- **DBMS(데이터베이스 관리 시스템)**는 이 데이터를 관리해주는 소프트웨어입니다. MySQL, PostgreSQL, Oracle 같은 게 DBMS에요. 우리가 "데이터베이스"라고 부르는 건 사실 대부분 DBMS를 말하는 겁니다.

**DBMS가 해주는 일**

- 여러 명이 동시에 접근해도 데이터 안 꼬이게 관리
- 중요한 데이터 백업하고 복구
- 보안 관리 (권한 없으면 못 봄)
- 데이터 무결성 보장 (잘못된 데이터 못 들어오게)

## 스키마 - 데이터베이스 설계도

스키마는 데이터베이스 구조를 정의한 것입니다. 건물 설계도처럼 "어떤 테이블이 있고, 각 테이블에 어떤 컬럼이 있는지" 정의하죠.

**3계층 스키마 구조**

**외부 스키마**: 사용자가 보는 뷰. 회계팀은 재무 데이터만, 영업팀은 고객 데이터만 보는 식으로 다르게 보임
**개념 스키마**: 전체 데이터베이스 구조. 보통 "스키마"라고 하면 이걸 말함
**내부 스키마**: 실제 물리적 저장 방식. 하드디스크에 어떻게 저장되는지

---

## 관계형 데이터베이스 (RDBMS)

## 테이블의 구조

**테이블(Table)**: 엑셀 시트처럼 행과 열로 구성
**행(Row)**: 하나의 데이터 덩어리. "레코드" 또는 "튜플"이라고도 부름
**열(Column)**: 데이터 속성. "필드" 또는 "애트리뷰트"라고도 부름

학생 테이블이라면:

```
| 학번 | 이름   |      학과     | 학년 |
|------|--------|--------|-----|
| 2024 | 김철수 | 컴퓨터   |   2   |
| 2025 | 이영희 | 경영학   |   1    |

```

여기서 각 행이 한 명의 학생이고, 각 열이 학생의 속성입니다.

## 엔티티와 속성

- **엔티티(Entity)**는 저장하고 싶은 대상입니다. 회원, 상품, 주문 같은 거죠. 실제 세계의 객체를 데이터베이스에 표현한 겁니다.

**강한 엔티티**: 혼자 존재 가능 (예: 회원, 상품)
**약한 엔티티**: 다른 엔티티에 의존 (예: 주문 상세 - 주문이 있어야 존재)

- **속성(Attribute)**은 엔티티의 특성입니다. 회원이라는 엔티티는 이름, 이메일, 가입일 같은 속성을 가지죠.

---

## Key (키)

## Key가 왜 필요할까?

같은 이름을 가진 사람이 100명이면 어떻게 구분할까요? 그래서 학번, 사원번호, 주민등록번호 같은 고유 식별자가 필요합니다.

## 후보키 (Candidate Key)

유일성과 최소성을 만족하는 키입니다. 학번도 될 수 있고, 주민등록번호도 될 수 있죠.

## 기본키 (Primary Key)

후보키 중 선택된 대표입니다. Null 불가, 중복 불가가 철칙입니다. 보통 자동 증가하는 id를 많이 씁니다.

## 외래키 (Foreign Key)

다른 테이블의 기본키를 참조합니다. 테이블끼리 관계를 맺어주는 핵심이죠.

주문 테이블에서 회원ID(외래키) → 회원 테이블의 회원ID(기본키)

---

## 정규화 (Normalization)

## 정규화가 필요한 이유

중복 데이터가 많으면 문제가 생깁니다. 학생의 학과 이름이 100군데 저장돼 있는데 학과명이 바뀌면? 100군데를 다 바꿔야 하고, 하나라도 빠뜨리면 데이터 불일치가 발생합니다.

## 이상 현상 (Anomaly)

**삽입 이상**: 불필요한 데이터 없이는 추가 불가. 교수가 아직 강의를 안 맡았는데 교수 정보를 입력 못 함
**갱신 이상**: 중복된 데이터 중 일부만 수정하면 데이터 불일치 발생
**삭제 이상**: 필요한 데이터까지 함께 삭제됨. 마지막 수강생이 취소하면 강의 정보도 사라짐

## 정규화 단계

**1차 정규화 (1NF)**

모든 속성 값이 원자값이어야 합니다. 한 칸에 "사과, 바나나, 포도" 이렇게 여러 개 넣으면 안 됩니다.

```
❌ 잘못된 예:
|  학생   |        수강과목      |
|-------|----------------|
| 김철수 | 수학, 영어, 국어 |

✅ 올바른 예:
| 학생 | 수강과목 |
|------|--------|
| 김철수 | 수학    |
| 김철수 | 영어    |
| 김철수 | 국어    |

```

**2차 정규화 (2NF)**

부분 함수 종속을 제거합니다. 기본키가 (학생, 과목)인데 나이는 학생에만 종속되면 분리해야 합니다.

**3차 정규화 (3NF)**

이행적 함수 종속을 제거합니다. 학생 → 학과코드 → 학과명 이런 식이면 학과는 별도 테이블로 분리합니다.

**BCNF (Boyce-Codd 정규형)**

모든 결정자가 후보키여야 합니다. 3NF보다 더 엄격한 버전입니다.

## 반정규화

정규화를 너무 하면 조인이 많아져서 성능이 떨어집니다. 그래서 의도적으로 중복을 허용하는 게 반정규화입니다. 읽기가 많은 시스템에서 성능 향상을 위해 사용하죠.

---

## 트랜잭션 (Transaction)

## 트랜잭션이란?

데이터베이스 상태를 변경하는 하나의 작업 단위입니다. 계좌 이체를 생각해보세요.

1. A 계좌에서 10만원 차감
2. B 계좌에 10만원 추가

이 둘은 하나로 묶여야 합니다. 1번만 성공하고 2번이 실패하면 돈이 증발하거든요.

## ACID 원칙

**Atomicity (원자성)**

All or Nothing. 전부 성공하거나 전부 실패하거나 둘 중 하나입니다. 중간 단계는 없어요.

**Consistency (일관성)**

트랜잭션 전후로 데이터베이스는 일관된 상태를 유지해야 합니다. 잔액이 음수가 되면 안 되는 규칙이 있다면, 트랜잭션은 이 규칙을 지켜야 합니다.

**Isolation (격리성)**

여러 트랜잭션이 동시에 실행돼도 서로 영향을 주지 않아야 합니다. A가 이체하는 동안 B가 잔액 조회하면 이상한 값이 보이면 안 되죠.

**Durability (지속성)**

커밋된 트랜잭션은 영구적으로 반영됩니다. 시스템이 죽어도 데이터는 남아있어야 합니다.

## Commit과 Rollback

**Commit**: 트랜잭션 성공 확정. 데이터베이스에 영구 반영됩니다.
**Rollback**: 트랜잭션 실패. 모든 변경사항을 취소하고 이전 상태로 돌아갑니다.

---

## 격리 수준 (Isolation Level)

## 동시성 문제

여러 트랜잭션이 동시에 실행되면 문제가 생길 수 있습니다.

**Dirty Read**: 커밋 안 된 데이터를 읽음
**Non-Repeatable Read**: 같은 쿼리를 두 번 실행했는데 결과가 다름
**Phantom Read**: 없던 데이터가 갑자기 나타남

## 격리 수준 단계

**Read Uncommitted** (제일 낮음)

커밋 안 된 데이터도 읽습니다. 모든 문제 발생 가능. 거의 안 씁니다.

**Read Committed**

커밋된 데이터만 읽습니다. Dirty Read는 방지. PostgreSQL, Oracle 기본값입니다.

**Repeatable Read**

트랜잭션 내에서 같은 쿼리는 같은 결과를 보장합니다. MySQL(InnoDB) 기본값입니다.

**Serializable** (제일 높음)

완전히 순차적으로 실행한 것처럼 동작합니다. 가장 안전하지만 성능이 떨어집니다.

격리 수준이 높을수록 안전하지만 동시성이 떨어지고, 낮을수록 동시성은 좋지만 문제 발생 가능성이 높습니다.

---

## 인덱스 (Index)

## 인덱스가 왜 필요할까?

책에서 "김철수"를 찾는데 1페이지부터 끝까지 다 뒤적이면 시간이 오래 걸립니다. 책 뒤 찾아보기(인덱스)를 보면 "김철수 - 152페이지" 하고 바로 찾을 수 있죠.

데이터베이스도 마찬가지입니다. 100만 건 중에서 특정 데이터를 찾을 때 인덱스가 있으면 훨씬 빠릅니다.

## 인덱스 동작 방식

인덱스는 (데이터, 위치) 쌍을 정렬된 상태로 저장합니다. 이진 탐색처럼 빠르게 찾을 수 있죠.

인덱스 없으면: O(n) - 처음부터 끝까지 다 봐야 함
인덱스 있으면: O(log n) - 훨씬 빠름

## B+Tree 자료구조

실제 DB는 대부분 B+Tree로 인덱스를 구현합니다. 균형 잡힌 트리 구조라 항상 일정한 속도를 보장하고, 범위 검색(BETWEEN, >, <)에 유리합니다.

## 인덱스 단점

**저장 공간 차지**: 인덱스도 데이터니까 용량을 씁니다
**쓰기 성능 저하**: INSERT, UPDATE, DELETE 할 때마다 인덱스도 같이 수정해야 합니다

그래서 무조건 인덱스를 많이 만드는 게 좋은 게 아닙니다. 자주 검색하는 컬럼에만 전략적으로 걸어야 합니다.

**인덱스 거는 게 좋은 컬럼**

- WHERE 절에 자주 등장
- JOIN에 자주 사용
- 정렬(ORDER BY)에 자주 사용
- 카디널리티가 높음 (중복이 적음)

---

## 조인 (Join)

## 조인이 뭘까?

두 개 이상의 테이블을 연결해서 데이터를 가져오는 겁니다. 정규화로 테이블을 나눴으니 다시 합쳐서 봐야 할 때가 있거든요.

## 조인 종류

**INNER JOIN (내부 조인)**

양쪽 테이블에 모두 있는 데이터만 가져옵니다. 가장 많이 씁니다.

```sql
SELECT * FROM 학생
INNER JOIN 수강 ON 학생.학번 = 수강.학번;

```

수강 신청을 한 학생만 나옵니다.

**LEFT JOIN (왼쪽 외부 조인)**

왼쪽 테이블 데이터는 전부, 오른쪽은 매칭되는 것만 가져옵니다.

```sql
SELECT * FROM 학생
LEFT JOIN 수강 ON 학생.학번 = 수강.학번;

```

수강 신청 안 한 학생도 나오는데, 수강 정보는 NULL입니다.

**RIGHT JOIN (오른쪽 외부 조인)**

LEFT JOIN의 반대입니다. 실무에서는 LEFT JOIN을 더 많이 씁니다.

**FULL OUTER JOIN**

양쪽 테이블의 모든 데이터를 가져옵니다. 매칭 안 되는 쪽은 NULL로 채워집니다.

---

## SQL 기본

## SQL이란?

Structured Query Language. 데이터베이스와 대화하는 언어입니다.

## 주요 명령어

**DDL (데이터 정의어)**

```sql
CREATE TABLE 학생 (학번 INT PRIMARY KEY, 이름 VARCHAR(50));
ALTER TABLE 학생 ADD 전화번호 VARCHAR(20);
DROP TABLE 학생;

```

**DML (데이터 조작어)**

```sql
INSERT INTO 학생 VALUES (1, '김철수');
SELECT * FROM 학생 WHERE 학과 = '컴퓨터';
UPDATE 학생 SET 학년 = 2 WHERE 학번 = 1;
DELETE FROM 학생 WHERE 학번 = 1;

```

**DCL (데이터 제어어)**

```sql
GRANT SELECT ON 학생 TO 사용자;
REVOKE SELECT ON 학생 FROM 사용자;

```

---

## NoSQL

## RDBMS의 한계

관계형 DB는 엄격한 스키마와 관계 구조 때문에 유연성이 떨어집니다. SNS 피드처럼 구조가 자주 바뀌는 데이터는 관리하기 어렵죠. 수평 확장(서버 여러 대로 분산)도 쉽지 않습니다.

## NoSQL 등장

Not Only SQL. SQL만이 답은 아니라는 겁니다. 스키마 없이 유연하게 데이터를 저장하고, 수평 확장이 쉽습니다.

## NoSQL 종류

**Key-Value 스토어**: Redis, Memcached

- 가장 단순. 캐시 용도로 많이 씀

**Document DB**: MongoDB, CouchDB

- JSON 형태로 저장. 스키마 유연함

**Column Family DB**: Cassandra, HBase

- 컬럼 단위로 저장. 대용량 데이터에 강함

**Graph DB**: Neo4j

- 관계 중심 데이터. SNS 친구 관계 같은 거

## RDBMS vs NoSQL

**RDBMS 쓸 때**

- 데이터 구조가 명확하고 변경 적음
- 트랜잭션이 중요 (금융, 결제)
- 복잡한 JOIN이 많음

**NoSQL 쓸 때**

- 대용량 데이터
- 데이터 구조가 자주 바뀜
- 수평 확장 필요
- 빠른 읽기/쓰기가 중요

---

## 동시성 제어

## Locking

여러 트랜잭션이 동시에 같은 데이터를 건드리면 문제가 생깁니다. 그래서 Lock을 걸어서 한 번에 하나씩만 접근하게 만듭니다.

**Shared Lock (공유 락)**

읽기용 Lock. 여러 트랜잭션이 동시에 읽을 수는 있지만 쓰기는 못 합니다.

**Exclusive Lock (배타 락)**

쓰기용 Lock. 다른 트랜잭션은 읽기도 쓰기도 못 합니다.

## 데드락 (Deadlock)

A 트랜잭션이 데이터1을 잡고 데이터2를 기다리는데, B 트랜잭션은 데이터2를 잡고 데이터1을 기다리면? 서로 무한정 기다리는 교착 상태가 발생합니다.

**해결 방법**

- 타임아웃 설정 (일정 시간 후 강제 종료)
- 데드락 감지 후 하나를 Rollback
- 트랜잭션 순서 통일 (항상 같은 순서로 Lock 획득)

---

## 파티셔닝과 샤딩

## 파티셔닝 (Partitioning)

큰 테이블을 작은 조각으로 나누는 겁니다. 물리적으로는 여러 조각이지만 논리적으로는 하나의 테이블입니다.

**수평 파티셔닝**: 행 단위로 나눔 (2020년 데이터, 2021년 데이터 분리)
**수직 파티셔닝**: 열 단위로 나눔 (자주 쓰는 컬럼 / 안 쓰는 컬럼 분리)

## 샤딩 (Sharding)

데이터를 여러 서버에 분산하는 겁니다. 수평 파티셔닝의 확장판이라고 보면 됩니다.

A~M 성은 서버1, N~Z 성은 서버2 이런 식으로요.

**장점**: 처리량 증가, 대용량 데이터 처리 가능
**단점**: JOIN 어려움, 트랜잭션 복잡, 특정 샤드에 부하 집중 가능

---

## 무결성 (Integrity)

## 무결성이란?

데이터의 정확성과 일관성을 보장하는 겁니다.

**개체 무결성**

기본키는 NULL이 될 수 없고, 중복될 수 없습니다.

**참조 무결성**

외래키는 참조하는 테이블에 실제로 존재하는 값이어야 합니다. 없는 회원 ID로 주문을 만들 수 없습니다.

**도메인 무결성**

컬럼 값은 정해진 범위 내에 있어야 합니다. 나이는 음수가 될 수 없고, 성별은 M/F만 가능하다는 식입니다.

**NULL 무결성**

NOT NULL 제약이 걸린 컬럼에는 NULL이 들어갈 수 없습니다.

---

## SQL Injection

## 공격 방법

사용자 입력을 그대로 SQL에 넣으면 위험합니다.

```sql
-- 로그인 쿼리
SELECT * FROM users WHERE id = '입력값' AND password = '입력값';

-- 공격자가 id에 "admin' --" 입력하면
SELECT * FROM users WHERE id = 'admin' -- AND password = '입력값';
-- 비밀번호 체크를 우회함!

```

## 방어 방법

**Prepared Statement 사용**

입력값을 SQL 문자열로 합치지 말고 파라미터로 전달합니다.

```java
String sql = "SELECT * FROM users WHERE id = ? AND password = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1, userId);
pstmt.setString(2, password);

```

**입력 검증**

특수문자 필터링, 화이트리스트 방식 검증을 합니다.

**최소 권한 원칙**

DB 계정에 필요한 권한만 줍니다. 웹 앱용 계정은 DROP, ALTER 권한이 필요 없습니다.