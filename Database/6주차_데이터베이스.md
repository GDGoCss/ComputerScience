## 데이터베이스 기본
### 데이터베이스란?
- 데이터베이스(DB): 단순히 데이터의 집합 ex. 엑셀 파일
- DBMS(Database Management System): 데이터베이스를 관리해주는 전문 소프트웨어 ex. MySQL

### DBMS의 필요성
#### 데이터 무결성 보장 문제
- 파일 시스템: 파일에 누군가 형식을 무시하고 적어도 막을 방법이 없음 ex. 나이를 음수로 작성
- DBMS: 제약조건을 설정할 수 있어 규칙에 어긋나는 데이터의 입력을 원천 차단
#### 데이터 중복과 불일치
- 파일 시스템: 정보가 하나라도 바뀌면 해당 정보가 포함된 모든 파일을 직접 찾아가며 수정해야 함. 하나라도 놓칠 경우 데이터 불일치
- DBMS: 데이터를 정규화하여 정보를 테이블에 단 한 번만 저장. 정보가 바뀌면 테이블의 레코드 하나만 수정하면 됨.
#### 동시성 제어 문제
- 파일 시스템: A와 B가 동시에 같은 파일을 열어 수정하고 저장하면 나중에 저장한 사람의 변경 사항만 남고 다른 사람의 작업은 덮어씌워져 유실됨
- DBMS: 트랜잭션과 로킹이라는 개념을 통해 여러 사용자가 동시에 데이터에 접근하고 수정하려 할 때 순서를 보장하고 데이터가 꼬이지 않게 제어함
#### 보안 및 권한 관리
- 파일 시스템: 특정 파일에 대한 읽기, 쓰기 권한 정도가 전부
- DBMS: `GRANT`, `REVOKE`같은 명령어를 통해 특정 사용자에게 특정 테이블의 특정 컬럼에 대한 권한만 주는 등 세밀한 권한 제어가 가능

## 관계형 데이터 모델과 키
### 관계형 데이터 모델이란?
- 모든 데이터를 릴레이션이라는 2차원 표 형태로 나타내는 방식
- 그래프나 트리 구조가 아닌 수학의 집합 이론과 술어 논리에 기반을 둔, 단순하고 논리적인 모델
### 관계형 데이터 모델 용어 정리
| 이론 용어 | 실무 용어 | 뜻 |
| :--- | :--- | :--- |
| 릴레이션(Relation) | 테이블(Table) | 데이터가 저장되는 전체 2차원 표 그 자체 |
| 튜플(Tuple) | 행(Row), 레코드(Record) | 테이블의 가로 한 줄 |
| 속성(Attribute) | 열(Column), 필드(Field) | 테이블의 세로 한 줄 |
| 도메인(Domain) | 데이터 타입 & 제약조건 | 그 열에 들어갈 수 있는 값의 범위 |
| 차수(Degree) | 열의 개수 | 속성의 수 |
| 기수(Cardinality) | 행의 개수 | 튜플의 수 |

### 키의 종류와 중요성
- 학생 테이블에 홍길동이 여러명일 때, 원하는 홍길동을 정확히 찾아내고 수정하려면?
- 키는 테이블 안에서 특정 한 줄을 유일하게 찾아낼 수 있도록 보장해주는 장치

[학생_테이블] 
| 학번 | 이름 | 학과 | 주민번호 | 이메일 |
| :--- | :--- | :--- | :--- | :--- |

#### 슈퍼키(Super Key)
- 테이블의 행을 유일하게 식별할 수 있는 속성들의 집합
- 유일성 만족, 최소성 만족X
- ex.
	- {학번}, {주민번호}, {학번, 이름}, {주민번호, 이름, 학과}
	- {이름, 학과} - 동명이인이 같은 과에 있을 수 있기 때문에 유일하지 않음.
- 유일하기만 하면, 쓸데없는 속성이 껴있어도 슈퍼키
#### 후보키(Candidate Key)
- 슈퍼키 중에서, 불필요한 속성을 뺀 최소한의 집합
- 유일성 만족, 최소성 만족
- ex.
	- {학번}, {주민번호}, {이메일}
	- {학번, 이름} - 이름을 빼도 학번만으로 유일함. 최소성 만족 X
#### 기본키(Primary Key, PK)
- 후보키 중에서 개발자가 선택한 단 하나의 키
- NULL값을 허용하지 않으며, 중복될 수 없음
- ex. 
	- {학번}, {주민번호}, {이메일} 중 보통 학번을 기본키로 선택.
	- 주민번호는 민감 정보이고, 이메일은 변경될 수 있으므로 기본키로 부적절
#### 대체키(Alternate Key)
- 후보키 중에서 기본키로 선택되지 않은 나머지 키들
- ex.
	- {주민번호}, {이메일}
- 여전히 유일성과 최소성을 만족
#### 외래키(Foreign Key, FK)
- 다른 테이블의 기본키를 참조하는 속성
- 테이블과 테이블을 연결하는 핵심 고리
- ex.
	- 학생 테이블(기본키: 학번)
	- 수강신청 테이블(기본키: 과목번호, ..., 학생_학번)
	- 여기서 수강신청 테이블의 학생_학번 컬럼은 학생 테이블의 학번을 참조하는 외래키
- 참조 무결성
	- DBMS는 외래키를 통해 데이터의 논리적 오류를 막아줌
	- ex. 학생 테이블에 존재하지 않는 학번을 가진 학생이 수강신청 테이블에 추가되는 것을 막아줌

## SQL
### SQL이란?
- Structured Query Language. 구조화된 질의 언어
- DBMS를 사용하는 양식
- 선언적 언어: SQL은 '어떻게' 데이터를 가져올지를 명령하는 것이 아닌, '무엇을' 원하는지를 선언만 하면 됨. '어떻게'는 DBMS가 알아서 결정
### DDL(Data Definition Language)
- 데이터 정의어
- 데이터의 구조를 만들고, 수정하고, 삭제하는 언어
- 대상: 데이터를 담는 그릇(테이블, 스키마, 뷰 등)
- `CREATE`: 테이블이나 데이터베이스를 생성
- `ALTER`: 만들어진 테이블의 구조를 수정
- `DROP`: 테이블 통째로 삭제(복구 어려움)
- `TRUNCATE`: 테이블의 구조는 남기고, 내부의 모든 데이터만 빠르게 삭제
```SQL
#Student 테이블 생성
CREATE TABLE Student(id INT PRIMARY KEY, name VARCHAR(20));
#이메일 컬럼 추가
ALTER TABLE Student ADD COLUMN email VARCHAR(50);
#Student 테이블 삭제
DROP TABLE Student;
#Student 테이블의 모든 데이터 삭제
TRUNCATE TABLE Student;
```

### DML(Data Manipulation Language)
- 데이터 조작어
- 테이블 안의 데이터를 직접 다루는 언어
- 대상: 테이블의 행 데이터
- `SELECT`: 데이터를 조회
- `INSERT`: 새 데이터를 삽입
- `UPDATE`: 기존 데이터를 수정
- `DELETE`: 특정 데이터를 삭제
```SQL
#학생 테이블에서 id가 1001인 학생의 이름과 이메일 조회
SELECT name, email FROM Student WHERE id=1001;
#학생 테이블의 id와 name 컬럼에 1004, '홍길동' 값 삽입
INSERT INTO Student (id, name) VALUES (1004, '홍길동');
#학생 테이블에서 id가 1001인 학생의 이메일을 'new@...'로 수정
UPDATE Student SET email='new@...' WHERE id=1001;
#학생 테이블에서 id가 1004인 행을 삭제
DELETE FROM Student WHERE id=1004;
```

### DCL(Data Control Language)
- 데이터 제어어
- 데이터베이스의 보안과 권한을 관리하는 언어
- 주로 DB 관리자가 사용
- `GRANT`: 특정 사용자에게 특정 권한을 부여
- `REVOKE`: 부여했던 권한을 회수
```SQL
#user에게 Student 테이블 조회 권한 부여
GRANT SELECT ON Student TO 'user'; 
#user에게 부여했던 권한 회수
REVOKE SELECT ON Student FROM 'user';
```

## 트랜잭션
### 트랜잭션이란?
- 계좌 이체
```SQL
#A 계좌에서 B 계좌로 10,000원을 이체하는 작업
UPDATE A_계좌 SET 잔액=잔액-10000;	(A의 잔액 감소)
UPDATE B_계좌 SET 잔액=잔액+10000;	(B의 잔액 증가)
```
- 만약 A의 잔액 감소는 성공했는데 B의 잔액 증가를 실행하기 전 서버가 다운되면 돈은 증발하고 은행의 총액이 맞지 않는 심각한 상황 발생
- 트랜잭션은 이러한 문제를 방지하기 위해 하나의 논리적인 작업 단위를 '둘 다 성공하거나 둘 다 실패해라' 라고 묶어주는 것
- A의 잔액 감소가 성공했지만 B의 잔액 증가가 실패하면 DB는 A의 잔액 감소까지 자동으로 취소(Rollback)시켜서 이체가 아예 없었던 일로 되돌려 버림
### ACID
- 트랜잭션의 4가지 특성
#### A(Atomicity, 원자성)
- All or Nothing
- 트랜잭션으로 묶인 작업들은 더 이상 쪼갤 수 없음
- 전부 성공(Commit)하거나, 하나라도 실패하면 전부 실패(Rollback)해야 함
#### C(Consistency, 일관성)
- 트랜잭션이 성공하든 실패하든, 데이터베이스는 항상 일관된 상태를 유지해야 함
- ex. 계좌 이체 전후에 은행의 총액은 항상 같아야 함
#### I(Isolation, 고립성)
- 여러 트랜잭션이 동시에 실행될 때, 서로의 작업에 끼어들거나 간섭할 수 없음
- 후에 병행제어에서 설명
#### D(Durability, 지속성)
- 트랜잭션이 성공적으로 완료되었다면 그 결과는 영구적으로 저장되어야 함
- Commit 직후에 서버가 다운되어도 그 결과는 이미 기록되어 사라지지 않음을 보장해야 함

### 병행제어
- DB는 고립성을 보장하기 위해 특정 데이터에 Lock을 걸어서 다른 트랜잭션이 접근하지 못하게 막는 Locking 기법을 사용

>ex. 티켓 예매 상황
>- 남은 좌석: 1석
>- A와 B가 동시에 예매 버튼을 누름
#### 고립성이 없을 경우(경쟁 상태)
- A: 남은 좌석은? DB: 1석
- B: (동시에) 남은 좌석은? DB: 1석
- A: 예매 성공(좌석 1석 -> 0석으로 변경)
- B: (동시에)예매 성공(좌석 1석 -> 0석으로 변경)
- 결과: 1개의 좌석을 2명이 예매하는 문제 발생(A의 갱신이 B의 갱신으로 덮어씌워지거나 무시됨)
#### Locking을 사용하여 문제 해결
- A: 남은 좌석은? DB: 1석
- A: 내가 예매할 거니까 Lock 걸어
- B: (동시에) 남은 좌석은? DB: 그거 A가 쓰고 있으니까 대기.
- A: 예매 성공(좌석 1석 -> 0석으로 변경), Lock 해제
- B: (A의 Lock이 풀리자) 남은 좌석은? DB: 0석
- 결과: B는 매진 화면을 보게 되며 데이터의 일관성을 지킴
