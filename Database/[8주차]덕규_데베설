🧠 데이터베이스 시스템 및 설계 개요 (Overview of Database Systems and Design)
I. 데이터베이스의 기본 개념과 특성
1️⃣ 데이터베이스의 정의

**데이터베이스(Database, DB)**란, 특정 조직이나 애플리케이션의 목적을 위해 논리적으로 연관된 데이터들의 집합을 체계적으로 저장·관리하는 시스템을 의미합니다.
단순한 데이터의 모음이 아닌, 데이터 간의 관계(Relationship), 제약조건(Constraint), **무결성(Integrity)**이 유지되는 통합된 구조를 가집니다.

📦 데이터베이스의 핵심 특성

특성	설명
통합성(Integrated)	데이터 중복을 최소화하여 일관성 유지
저장성(Stored)	외부 기억장치에 저장되어 지속성(Persistence) 보장
운영성(Operational)	실시간 트랜잭션 처리가 가능한 상태로 유지
공용성(Shared)	다수 사용자 및 프로세스가 동시에 접근 가능
내용 기반 참조(Content-based Access)	주소나 위치가 아닌 속성값을 기준으로 접근

💡 예시
은행 DB에서는 “계좌번호”를 통해 고객 데이터를 참조하고, “거래 내역”은 계좌 엔터티와 관계를 맺습니다.

➕ 확장(전공 심화)

데이터 품질 속성: 정확성, 일관성, 완전성, 최신성, 가용성, 추적성(감사 로그) 등은 설계·운영 전 과정의 평가 기준입니다.

데이터 모델 3계층: 개념/논리/물리 모델의 구분을 명확히 하여 변경 영향 범위를 줄입니다(개념→ERD, 논리→정규 스키마, 물리→파일·페이지·인덱스 설계).

워크로드 관점: OLTP(짧은 트랜잭션, 높은 동시성) vs OLAP(대용량 스캔, 복잡 집계) 특성은 스키마·인덱스·파티셔닝 전략을 달리 요구합니다.

II. DBMS (Database Management System)
1️⃣ 정의

DBMS는 데이터베이스를 정의·조작·제어하는 기능을 통합적으로 제공하는 소프트웨어 시스템입니다.
데이터 중복(Redundancy)과 종속(Dependency)을 제거하여 **데이터 독립성(Data Independence)**을 보장합니다.

2️⃣ DBMS의 주요 기능
기능	설명
정의(Definition)	스키마(Schema) 정의: 데이터의 논리적 구조(개체, 관계, 제약조건 등)와 물리적 구조(저장, 인덱스 등)를 명세
조작(Manipulation)	CRUD(Create, Read, Update, Delete) 연산 수행
제어(Control)	데이터 무결성, 보안, 병행 제어(Concurrency Control), 회복(Recovery) 관리
3️⃣ 3단계 DB 구조 (ANSI/SPARC Architecture)

외부 스키마 (External Schema) – 사용자 View (예: View 정의)

개념 스키마 (Conceptual Schema) – 전체 DB의 논리적 구조 (ER 모델 기반)

내부 스키마 (Internal Schema) – 물리적 저장구조 및 접근 경로 정의
→ 이 세 단계는 데이터 독립성의 핵심 기반입니다.

➕ 확장(전공 심화)

핵심 모듈: 스토리지 매니저(파일/페이지/버퍼관리), 쿼리 프로세서(파서→논리계획→물리계획→실행기), 트랜잭션 매니저(동시성/복구), 카탈로그/통계(메타데이터/히스토그램).

성능 지표: 카디널리티 추정 오차가 계획 선택(해시조인/소트머지/네스티드루프)에 미치는 영향, 버퍼 히트율, I/O 비용 모델(#page reads/writes).

보안 모델: DAC/RBAC/MAC, 행·열 수준 마스킹, Row-Level Security, 감사(ACID와 별개로 Auditability 강조).

III. 데이터 독립성 (Data Independence)
구분	보호 대상	예시
논리적 데이터 독립성	응용 프로그램이 개념적 스키마 변경으로부터 보호	테이블 분리/병합 시에도 View 기반 질의는 동일
물리적 데이터 독립성	응용 프로그램이 물리적 저장 변경으로부터 보호	파일 구조 변경, 인덱스 추가 시 영향 없음

➕ 확장(전공 심화)

뷰와 스키마 진화: 뷰/동의어/컴패티빌리티 레이어로 API 안정성 확보.

물리 독립성 사례: 클러스터형 인덱스 변경, 파티션키 교체, 압축/페이지 크기/스토리지 클래스 변경에도 SQL 불변 유지.

🧩 II. 개념적 설계: E-R 모델 (Entity-Relationship Model)
1️⃣ 개체(Entity)와 속성(Attribute)

개체(Entity): 현실 세계에서 구분 가능한 객체. (학생, 강의, 교수)

속성(Attribute): 개체의 특성 (이름, 학번, 전공)

도메인(Domain): 속성 값이 가질 수 있는 값들의 집합.

속성 유형	설명
단일값(Single-valued)	하나의 값만 가짐 (ex. 학번)
다중값(Multivalued)	여러 값을 가짐 (ex. 전화번호) → ERD에서 이중선 타원
유도(Derived)	다른 속성으로부터 계산 (ex. 나이=오늘−생일)
널(Null)	값이 없거나 적용되지 않음 (unknown, not applicable)

약개체(Weak Entity)

자체적인 기본키를 갖지 않음.

**식별자(Identifying Relationship)**로 소유자 키를 상속.
→ 약개체: 이중 직사각형, 식별관계: 이중 마름모.

➕ 확장(전공 심화)

키 설계의 실제: 자연키 vs 대리키(서로게이트키) 트레이드오프—참조 단순성/변경 안정성/중복 위험.

그레이드 속성: 주소/이메일처럼 정규화 경계가 애매한 속성은 독립 엔터티로 승격해 변경 이력(SCD) 관리 고려.

2️⃣ 관계 (Relationship)
구분	설명
차수(Degree)	이항/삼항/고차 관계(삼항 이상은 릴레이션 맵핑 시 주의)
참여 제약	전체/부분 참여
카디널리티	1:1, 1:N, M:N

💡 예시

교수–강의: 1:N

학생–수강: M:N

➕ 확장(전공 심화)

M:N 분해 규칙: 조인 테이블(교차 엔터티) + 2×FK + (필요 시) 추가 속성(예: 수강일, 성적).

삼항 관계의 분해 함정: 단순한 2개 이항 조인으로 동등 표현 불가한 제약이 존재(삼항 관계 유지가 의미적 제약을 보존).

3️⃣ ISA 계층 구조 (ISA Hierarchy)

ISA(상속): “A ISA B” → A ⊆ B

중첩(Overlap) / 포괄(Covering) 제약

💡 예시

교직원 → 교수/행정직(포괄 여부, 중첩 여부 정의)

➕ 확장(전공 심화)

매핑 전략(관계형 변환):

Single Table Inheritance(단일 테이블 + 구분자)

Class Table Inheritance(상위/하위 분리, FK 연결)

Concrete Table(하위만 물리화, 상위 없음)
성능/정규화/NULL 빈도/조인 비용을 기준으로 선택.

4️⃣ 집단화 (Aggregation)

관계 자체를 다른 관계의 엔터티처럼 다룸(프로젝트–부서의 관리 관계를 상위에서 다시 참조).

➕ 확장(전공 심화)

ER→릴레이션 변환 시 주의: 집단화는 종종 교차 엔터티 + FK 묶음으로 풀어야 의미 제약 보존.

🧱 III. 관계형 모델 (Relational Model)
1️⃣ 릴레이션의 구성 요소

(원문 표 유지) + 원자성(Atomicity) 조건.

➕ 확장(전공 심화)

백(Value- vs Bag-Semantics): 이론은 Set(중복 제거)이지만, SQL은 Bag(중복 허용). DISTINCT가 의미·성능에 영향.

NULL 의미론: 미확정/부적용/불명확 값의 구분 필요(도메인 모델링 단계에서 “NULL을 줄이는 스키마” 설계가 중요).

2️⃣ 무결성 제약조건

(개체/참조/도메인 무결성 유지)

➕ 확장(전공 심화)

체크 제약/CANDIDATE UNIQUE: 비즈니스 규칙의 DB 내장화가 응용-DB 불일치를 줄임.

지연 제약(DEFERRABLE): 트랜잭션 종료 시점 검증으로 대량 로딩/배치 유리.

3️⃣ 키 (Keys)

(슈퍼키/후보키/기본키/대체키/외래키 유지)

➕ 확장(전공 심화)

후보키 판정: 속성폐쇄(Attribute Closure) 알고리즘으로 최소성 검증.

복합키와 인덱싱: 복합 인덱스의 프리픽스 규칙(왼쪽부터 선택성 영향).

🧮 IV. 관계 대수 (Relational Algebra)
1️⃣ 기본 연산 / 2️⃣ 조인 / 3️⃣ Division

(원문 유지)

➕ 확장(전공 심화)

확장 연산: 일반화 투영(산술/함수 포함), 세미조인(⋉/⋊), 앤티조인(▷), 할당(←).

비용 모델:

선택(σ): 선택성 s → 결과 |R|·s

투영(π): 중복 제거 비용(정렬/해시 필요)

조인: Nested-Loop / Index-NL / Sort-Merge / Hash Join 선택은 입력 크기·정렬 여부·가용 인덱스·메모리에 따라 달라짐.

대수↔SQL 매핑: 옵티마이저는 SQL을 대수 트리로 변환 후 법칙(교환/결합/분배)을 적용해 선택·투영 밀어넣기로 I/O 최소화.

💬 V. 관계형 질의 언어: SQL
1️⃣ SQL 질의 구조 & 평가 단계

(원문 유지: FROM→WHERE→SELECT→DISTINCT)

➕ 확장(전공 심화)

집합 vs 배깅: UNION(중복 제거) vs UNION ALL(그대로).

서브쿼리: 스칼라/인라인뷰/상관/비상관, EXISTS/NOT EXISTS의 반조인적 의미.

윈도우 함수: OVER(PARTITION BY ... ORDER BY ...) + ROWS/RANGE 프레임—OLAP 질의 핵심.

CTE/재귀 CTE: 그래프/계층 질의(조직도·카테고리).

실행계획: 카디널리티 추정, 선택성, 조인 순서/방식, 인덱스 사용/스캔 전략(인덱스 전범위/커버링/시크+르쿠프).

2️⃣ 주요 SQL 기능

(원문 표 유지: 집합, LIKE, 집계, GROUP BY/HAVING, NULL, 트리거, 뷰)

➕ 확장(전공 심화)

무결성 도구: PRIMARY/UNIQUE/FOREIGN KEY, CHECK, 부분 인덱스/함수 인덱스.

머티리얼라이즈드 뷰: 집계 캐시/리프레시 전략(완전/증분).

트리거 주의: 순환 호출, 성능, 트랜잭션 경계, 멱등성 보장.

시간/버전 테이블: 시스템 시간(AS OF)과 애플리케이션 시간 이력 관리.

3️⃣ 권한 관리 (Authorization)

(원문 유지: GRANT/REVOKE)

➕ 확장(전공 심화)

역할 기반(RBAC), 컬럼/행 수준 보안, 뷰를 통한 최소 권한 원칙(Least Privilege) 실현.

WITH GRANT OPTION의 연쇄성과 RESTRICT/CASCADE 영향 분석.

🧩 VI. 스키마 설계 및 정규화 (Schema Design & Normalization)
1️⃣ 이상(Anomalies)

(원문 유지: 삽입/삭제/갱신 이상)

➕ 확장(전공 심화)

설계 목표: 정보무손실, 종속성 유지, 중복 최소화, 업데이트 비용 최소화의 균형.

실무 트레이드오프: 실시간 조인 비용 vs 중복 허용(디노말라이제이션), 변경 경로 단순성.

2️⃣ 함수 종속성 (FD)

(원문 유지 + 암스트롱 공리)

➕ 확장(전공 심화)

정규화 절차 핵심 알고리즘

**속성 폐쇄 X⁺**로 키 판정

FD 최소 커버(Canonical Cover) 도출(우변 단일화→좌변 최소화→중복 제거)

분해 시 무손실 판정: R1∩R2가 R1 또는 R2의 수퍼키이면 무손실(빈번한 충분조건).

종속성 유지 판정: 분해된 스키마의 FD 합집합으로 원래 FD 유도 가능 여부 확인.

3️⃣ 정규형 (Normal Forms)

(원문 표 유지: 1NF/2NF/3NF/BCNF)

➕ 확장(전공 심화)

고급 정규형

4NF: 다중값 종속(MVD) 제거(독립 반복 그룹 분리).

5NF(Projection-Join NF): 조인 종속(JD) 기반—드물지만 삼항 관계 분해의 정확성 이슈에 중요.

3NF vs BCNF 선택: BCNF는 종속성 미유지 위험 → 질의/제약 구현 복잡도가 커지면 3NF가 현실적일 수 있음.

4️⃣ 분해 원리

(원문 유지: 무손실/종속성 유지)

➕ 확장(전공 심화)

알고리즘 예

3NF 합성: 최소 커버 기반으로 각 FD X→A에 대해 스키마 XA 생성(+키 포함 보장). 종속성 유지 + 무손실(키 포함) 보장.

BCNF 분해: 위반 FD X→Y에 대해 R을 XY ∪ (R−(Y−X))로 분해, 고정점까지 반복—무손실 보장이나 종속성 유지 보장 X.

🔒 VII. 트랜잭션, 동시성 제어, 회복(추가)

➕ 확장(전공 심화)

ACID: Atomicity, Consistency, Isolation, Durability.

격리수준(ISO/ANSI): Read Uncommitted / Read Committed / Repeatable Read / Serializable.

현상: Dirty/Non-repeatable/Phantom Read.

MVCC: 스냅샷 기반 읽기(Phantom은 인덱스 레인지락/Serializable로 차단).

직렬가능성 이론: 충돌 직렬가능성(Precedence Graph 무사이클), 뷰 직렬가능성.

제어기법: 2PL(보통 Strict 2PL), 타임스탬프 오더링, 검증(Optimistic).

데드락: Wait-For 그래프 검출 또는 타임아웃 회피.

회복(ARIES): WAL, 체크포인트, 분류(Analysis)→재실행(Redo)→역실행(Undo), LSN/Dirty Page Table/트랜잭션 테이블.

📦 VIII. 물리적 설계와 인덱싱(추가)

➕ 확장(전공 심화)

저장구조: 힙 파일, 클러스터드/넌클러스터드, 슬롯 페이지, 가변 길이 레코드.

인덱스: B⁺-트리(범위/순차 우수), 해시(정확 매칭), 비트맵(저카디널리티), 파셜/함수 인덱스, 커버링 인덱스.

조인 알고리즘 선택: 입력 크기·정렬 여부·메모리·인덱스 유무.

파티셔닝: 범위/해시/리스트/합성, 로컬 vs 글로벌 인덱스, 파티션 프루닝.

복제/샤딩: CAP·PACELC 관점(일관성/가용성/지연 트레이드오프).

🌐 IX. 확장 주제(추가 요약)

➕ 확장(전공 심화)

관계 해석(Relational Calculus): 튜플/도메인 해석, 안전성(Safety) 개념—SQL의 이론적 근거.

NoSQL 간단 비교: 키-값/문서/열지향/그래프—스키마 유연성, 수평 확장, 일관성 모델 차이.

데이터 거버넌스: DQ 지표, 메타데이터 관리, 데이터 계보(Lineage), GDPR/개인정보 마스킹.

🧭 VII. 요약 및 실무 연관성 (원문 유지 + 보강)
개념	실제 적용 예시
ER 모델링	요구사항 분석 단계에서 ERD 작성(ISA·집단화의 매핑 전략 선택 포함)
정규화	중복·갱신 이상 제거, 질의패턴 고려해 3NF/BCNF/부분 디노말 선택
무결성 제약	DB 레벨 비즈니스 규칙(FOREIGN KEY, CHECK, UNIQUE, DEFERRABLE)
관계 대수	옵티마이저의 변환 규칙(선택/투영 밀어넣기, 조인 재배열)의 이론 기반
SQL 권한관리	RBAC + Row-Level Security + 뷰로 최소 권한 원칙 준수
데이터 독립성	스키마 진화/물리 변경에도 API 안정성 유지(View·컴패티빌리티 레이어)
물리 설계	B⁺-트리/해시 인덱스, 파티셔닝, 조인 알고리즘, 버퍼 최적화
트랜잭션	고동시성 OLTP에서 2PL/MVCC·격리 수준 선택으로 현상 제어
복구	ARIES 기반 로그와 체크포인트로 장애 후 일관성 복원