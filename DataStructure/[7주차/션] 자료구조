# Array, ArrayList

### 시간복잡도

조회 : 둘 다 인덱스 접근으로 O(1)

삽입/삭제 : 중간에 데이터 삽입/삭제 시 모든 데이터 밀거나 당겨야함 (Shifting) → O(N)

# LinkedList

Array의 단점 해결.

각 원소들은 자신의 다음이 어떤 원소인지만 알고있음

원하는 위치로 한번에 접근 불가능. 원하는 위치에 삽입시, 첫번 째 원소부터 확인하는 search 과정 필요.

### 시간복잡도

탐색은 O(N), 실행은 O(1)

1. 맨 처음, 맨 끝 삽입/삭제 시 O(1) 가능
2. 데이터 순회 과정에서 삽입/수정 시 O(1) 가능

---

# Tree

Binary Tree : 자식 노드가 두 개인 노드들로 구성된 트리

## BST (Binary Search Tree)

이진 탐색 + 연결 리스트 결합한 자료구조

- 장점 : 이진 탐색의 효율적 탐색 능력 + 빈번한 삽입,삭제 가능
- 특징 : 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야하고, 오른쪽 트리 값은 부모 노드보다 커야한다.

### 시간복잡도

검색, 삽입, 삭제 → O(logN)

worst case : 트리 균형이 한쪽으로 치우쳐진 경우 → O(n)

### worst case 해결 방법 (Self-Balancing BST)

자가 균형 BST (Self-Balancing BST) 사용. 균형을 유지하여 높이를 가능한 낮게 유지시킴

종류 : AVL트리, Red-black tree

## Red-Black Tree

BST 기반으로 하는 트리 형식 자료구조.

- BST를 기반으로 하기에, BST의 특징을 모두 가짐.
- BST의 삽입,삭제 연산 과정에서의 문제점 (편향 트리)을 해결하기 위해 만들어짐.

특징 :

- 모든 노드는 red, black 둘 중 하나
- 노드의 child가 없을 경우, child를 가리키는 포인터는 NIL 값을 저장. 이를 leaf node로 간주.
- 루트, 리프 노드는 black
- Red의 자식은 무조건 Black
- 모든 노드에서 리프 노드까지의 경로의 Black 노드 수는 같다.

---

# Heap

완전이진트리를 기반으로 하여, 최댓값 또는 최솟값을 빠르게 찾아내기 위한 자료구조.

삽입-삭제에 O(logN)

최댓값-최솟값 확인 O(1)

## 시간복잡도

삽입 : 새로운 값을 마지막 노드에 넣고 swap 하며 정렬 → O(logN)

삭제 : 루트 노드 pop & 마지막 노드를 루트에 넣음. 그리고 swap으로 정렬 → O(logN)

## 힙을 배열로 구현하는 이유

- 완전이진트리 기반이므로, 배열의 index로 부모-자식 index 쉽게 찾을 수 있음.
- linkedList로 노드 구현시, 데이터+포인터 등 합쳐져 메모리 차지함. 인덱스 기반으로 해당 문제 해결.

## B-Tree, B+Tree

B-Tree :

이진 트리를 확장해 모든 리프 노드들이 같은 높이를 갖도록 하는 트리.

정렬된 N개의 Key를 가질 수 있고, 자식 노드는 N+1개가 됨.

B+Tree : 리프 노드에만 데이터가 있으며, 각 리프 노드가 연결 리스트 형태를 띄어 선형 검색 가능.

---

# Hash Table

(key, value)로 데이터 저장하는 자료구조 중 하나.

각 key값이 고유한 index를 가져 바로 접근 가능 → 평균 O(1) 조회.

### 시간복잡도 O(1) 가능한 이유

해시 테이블은 내부적으로 배열 사용하여 데이터 저장.

해시 함수를 적용해 Key 값을 구해 배열의 인덱스 연산으로 바로 조회 가능.

### 해시 함수

임의의 길이 데이터를 고정 길이 데이터로 매핑하는 함수.

해시 테이블에서는 키에 대한 해시값을 인덱스로 활용.

### 좋은 hash function

연산 속도가 빠르고, 해시값이 최대한 고르게 분포되게 하는 함수

### 해시 테이블 단점

- 배열에 데이터를 저장하므로 공간 효율성이 떨어짐.
- 순서를 보장하지 않아 순서,관계 필요시 적합하지 않음

## 해시 테이블 충돌

서로 다른 데이터가 같은 해시값을 가지는 것. 자주 발생시 삽입, 조회에 있어 해시 테이블 성능 감소.

## 충돌 해결방법

### 1. open addressing

collision 발생시 미리 정한 규칙에 따라 비어있는 해시테이블에 데이터 저장하는 방식.

장점 : 추가적인 메모리를 사용 X. 비교적 메모리 적게 사용.

단점 :

- 충돌 횟수 많아지면 특정 영역에 데이터 집중적으로 몰리는 클러스터링 현상 발생 가능.
- 조회, 삽입, 삭제 시 인덱스의 키 값이 찾고자 하는 값이 아니면 추가적 탐색 필요함.

### 2. separate chaining

linked list 이용하여 충돌 발생시 노드를 추가해 데이터 저장.

장점 : 구현이 간단함.

단점 :

- 추가 메모리 사용
- 조회 성능이 O(1)보다 안좋아짐.
- 최악의 경우 (n개의 모든 key가 동일한 해시값 가질 시)  길이가 n인 linked list가 생성되고, 검색 삭제에 있어 O(n) 시간 복잡도 가지게 됨.

## 충돌 잦은 경우 어떻게 해야 할까

해시테이블이 아닌 다른 자료구조를 알아보기.

해시 테이블 사용해야 한다면, 해시 함수를 적절히 선택.

해시 테이블 75% 이상 차있다면 테이블 확장 고려.

separate chaining 에서 linked list가 아닌 tree 사용함으로서 최악의 경우에도 O(logN) 시간 보장