## OSI 7계층 각 단계별 역할
#### 제 7계층: 응용 계층 (Application Layer)
- 역할: 사용자가 네트워크 자원에 접근할 수 있도록 서비스와 인터페이스를 제공. 우리가 실제로 사용하는 프로그램들이 이 계층에 해당
- 핵심 키워드: 사용자 인터페이스, 데이터 생성
- 대표 프로토콜: HTTP(웹), FTP(파일 전송), SMTP(이메일), DNS

#### 제 6계층: 표현 계층 (Presentation Layer)
- 역할: 데이터의 형식(Format)을 결정하고, 데이터를 안전하게 보내기 위해 **암호화(Encryption)**하거나 전송 용량을 줄이기 위해 **압축(Compression)**하는 역할
- 핵심 키워드: 데이터 변환, 암호화, 압축
- 대표 형식: JPEG, MPEG, ASCII

#### 제 5계층: 세션 계층 (Session Layer)
- 역할: 두 컴퓨터 간의 대화, 즉 세션(Session)을 만들고, 유지하고, 끝내는 역할을 담당. 통신 중에 연결이 끊겼을 때 어디서부터 다시 시작할지 정하는 동기화 기능도 제공.
- 핵심 키워드: 연결 설정, 대화 제어, 동기화
- 대표 프로토콜: NetBIOS, RPC

#### 제 4계층: 전송 계층 (Transport Layer)
- 역할: 데이터가 정확하고 신뢰성 있게 전달되도록 보장하는 역할. 포트 번호(Port)를 사용해서 어떤 프로그램으로 데이터를 보낼지 지정하고, 데이터의 흐름을 제어하거나 오류를 검사하고 복구.
- 핵심 키워드: TCP/UDP, 포트 번호, 신뢰성, 흐름 제어
- 데이터 단위: 세그먼트 (Segment)
- 대표 장비: 게이트웨이

#### 제 3계층: 네트워크 계층 (Network Layer)
- 역할: 데이터를 목적지까지 갈 수 있는 최적의 경로를 찾아주는 역할(라우팅). 이때 사용되는 논리적인 주소가 바로 IP 주소.
- 핵심 키워드: IP 주소, 라우팅
- 데이터 단위: 패킷 (Packet)
- 대표 장비: 라우터 (Router)

#### 제 2계층: 데이터 링크 계층 (Data Link Layer)
- 역할: 같은 네트워크에 있는 장치들끼리 데이터를 주고받을 수 있도록 해주는 역할. 물리적인 주소인 MAC 주소를 사용해서 통신하고, 물리 계층에서 발생할 수 있는 오류를 감지하고 수정.
- 핵심 키워드: MAC 주소, 프레임, 오류 제어
- 데이터 단위: 프레임 (Frame)
- 대표 장비: 스위치 (Switch), 브리지

#### 제 1계층: 물리 계층 (Physical Layer)
- 역할: 데이터를 **0과 1의 전기 신호(비트)**로 변환해서 케이블 같은 물리적인 매체를 통해 전송하는 역할. 데이터의 내용에는 신경 쓰지 않고 오직 신호를 보내고 받는 것만 담당
- 핵심 키워드: 전기 신호, 케이블, 비트
- 데이터 단위: 비트 (Bit)
- 대표 장비: 허브, 리피터, 케이블

---

## TCP/IP 심화
### 3-Way & 4-Way Handshake
TCP는 신뢰성 있는 연결을 위해 통신 전에 서로 준비가 되었는지 확인하는 연결 설정(3-Way Handshake) 과정과, 데이터를 모두 보냈는지 확인하고 안전하게 종료하는 연결 해제(4-Way Handshake) 과정을 거침.

#### 3-Way Handshake: 연결 설정 과정
"통신 준비 됨?" -> "준비 됨. 넌 됨?" -> "ㅇㅇ됨 통신 ㄱㄱ"

1. Client -> Server (SYN)
- 클라이언트: 서버에 접속을 요청하는 `SYN` 패킷을 보냄. "연결 요청할게"라는 의미
- Client 상태: `CLOSED` -> `SYN_SENT` (SYN을 보냈다는 의미)
- Server 상태: `LISTEN` (클라이언트의 요청을 기다리는 중)

2. Server -> Client (SYN + ACK)
- 서버: 클라이언트의 요청을 받고, "요청 받음. 나도 통신 준비 됨" 라는 의미로 `ACK`와, "너도 준비 됨? 대답좀" 이라는 `SYN`을 함께 보냄
- Server 상태: `LISTEN` -> `SYN_RCV` (SYN을 받았다는 의미)

3. Client -> Server (ACK)
- 클라이언트: 서버의 `SYN`을 받고, "ㅇㅇ 준비 됨. 통신ㄱㄱ" 이라는 의미로 `ACK`를 보냄
- Client 상태: `SYN_SENT` -> `ESTABLISHED` (연결이 확립됨)
- Server 상태: `SYN_RCV` -> `ESTABLISHED` (연결이 확립됨)

이 3단계가 끝나면 비로소 ESTABLISHED 상태가 되어 실제 데이터 전송을 시작

#### 4-Way Handshake: 연결 해제 과정
"나 보낼 거 다 보냄" -> "잠만. 나도 남았음" -> "이제 다 보냄. 끊어도 됨" -> "ㅇㅋ 끊는다"

1. Client -> Server (FIN)
- 클라이언트: "전송 이제 끝낸다." 라는 `FIN`을 보냄
- Client 상태: `ESTABLISHED` -> `FIN_WAIT_1`

2. Server -> Client (ACK)
- 서버: "ㅇㅋ 확인함.  근데 나 아직 다 안 보냈으니까 잠만 ㄱㄷ" 라는 `ACK`를 보냄
- Server 상태: `ESTABLISHED` -> `CLOSE_WAIT` (클라이언트의 종료를 기다리는 중)
- Client 상태: `FIN_WAIT_1` -> `FIN_WAIT_2` (서버가 끝날 때까지 기다림)

3. Server -> Client (FIN)
- 서버: 남아있던 데이터를 모두 보내고, "전송 끝남. ㄹㅇ끊어도 됨" 이라는 `FIN`을 보냄
- Server 상태: `CLOSE_WAIT` -> `LAST_ACK` (마지막 ACK를 기다림)
 
4. Client -> Server (ACK)
- 클라이언트: "ㅇㅋ 확인" 라는 마지막 `ACK`를 보냄.
- Client 상태: `FIN_WAIT_2` -> `TIME_WAIT`
- Server 상태: `LAST_ACK` -> `CLOSED` (완전히 종료)

예상 면접 질문: `TIME_WAIT` 상태는 왜 필요한가?

`TIME_WAIT`는 클라이언트가 마지막 `ACK`를 보낸 후 바로 연결을 닫지 않고, 혹시나 네트워크 문제로 마지막 `ACK`가 서버에 도달하지 못했을 경우를 대비하기 위해 잠시 기다리는 상태입니다. 
만약 서버가 `ACK`를 못 받으면 `FIN`을 재전송할 것이고, 이때 클라이언트는 다시 `ACK`를 보내줄 수 있습니다. 이 상태 덕분에 연결이 안전하게 종료되는 것을 보장합니다.

### 흐름 제어(Flow Control) vs 혼잡 제어(Congestion Control)
둘 다 데이터 전송량을 조절하는 기술이지만, 조절하는 이유와 대상이 다릅니다.

#### 흐름 제어 (Flow Control)
- 목적: 송신측과 수신측 사이의 데이터 처리 속도 차이를 해결하기 위함.
- 상황: 송신측이 너무 빨리 보내서 수신측의 버퍼(데이터 임시 저장 공간)가 넘쳐 데이터가 유실되는 것을 방지.
- 핵심 원리: 슬라이딩 윈도우 (Sliding Window)
    1. 수신측은 자신이 한 번에 받을 수 있는 데이터의 양, 즉 윈도우 크기(Window Size)를 ACK 패킷에 담아 송신측에 계속 알려줌.
    2. 송신측은 수신측이 알려준 윈도우 크기만큼만 ACK 없이 연속으로 데이터를 보냄.
- ex. A가 B에게 물건을 던져줄 때, B가 "나 지금 두 개밖에 못 받아!"라고 외치면 A는 딱 두 개만 던져주는 것

#### 혼잡 제어 (Congestion Control)
- 목적: 송신측과 수신측 사이의 네트워크가 혼잡해지지 않도록 데이터 전송량을 조절.
- 상황: 데이터의 양이 네트워크의 처리 용량을 초과하여 패킷 유실이나 전송 지연이 발생하는 것을 방지.
- 핵심 원리: 알고리즘의 조합
    1. 슬로우 스타트 (Slow Start): 처음에는 윈도우 크기(cwnd)를 작게 시작해서,
       문제없이 ACK가 올 때마다 지수적으로(1 -> 2 -> 4 -> 8...) 빠르게 크기를 늘려가며 네트워크의 수용량을 탐색.
    2. 혼잡 회피 (Congestion Avoidance): 윈도우 크기가 임계점(Threshold)에 도달하면,
       급격한 증가를 멈추고 선형적으로(1씩) 크기를 완만하게 늘려가며 조심스럽게 전송량을 조절.
    3. 빠른 회복/재전송 (Fast Recovery/Retransmit): 패킷이 유실되었다고 판단되면(중복 ACK 3회 수신),
       윈도우 크기를 1로 확 줄이지 않고 절반으로 줄인 뒤 선형적으로 증가시켜,
       네트워크 혼잡을 완화하면서도 전송 효율이 급격히 떨어지는 것을 방지.  
- ex. 고속도로에 진입할 때(Slow Start), 처음에는 뻥 뚫려있으니 속도를 빠르게 올리다가, 차가 많아지는 지점(임계점)부터는(Congestion Avoidance) 눈치 보며 서서히 속도를 올리는 것. 사고(패킷 유실)가 나면 속도를 확 줄였다가 다시 서서히 증가
