# 5주차

## OSI 7계층

## 계층 구조가 왜 필요할까?

네트워크 통신을 7단계로 나눈 건 단순히 복잡하게 만들려는 게 아닙니다. 각 계층이 독립적으로 동작하면서도 인접 계층끼리만 소통하기 때문에, 웹 서버 프로토콜을 바꾼다고 해서 아래 물리 계층까지 건드릴 필요가 없거든요. 문제가 생겼을 때도 "아, 네트워크 계층에서 라우팅이 꼬였구나" 하고 바로 찾아낼 수 있죠.

## 각 계층이 하는 일

**7계층 - 응용 계층**

우리가 직접 만지는 프로그램들이 여기서 돌아갑니다. 크롬으로 구글 검색할 때 HTTP가, 파일 올릴 때 FTP가 작동하는 곳이죠. 개발자 입장에서는 이 계층만 신경 쓰면 나머지는 알아서 처리됩니다.

**6계층 - 표현 계층**

데이터를 어떤 형태로 보여줄지 결정합니다. 같은 이미지 파일도 JPEG로 압축할지, PNG로 보낼지 여기서 정하죠. 암호화도 이 계층에서 일어나서, 평문으로 날아가던 데이터가 알아볼 수 없는 암호문으로 바뀝니다.

**5계층 - 세션 계층**

두 컴퓨터 간의 대화를 관리합니다. 로그인 상태를 유지하거나, 파일 전송 중간에 끊겼을 때 이어받기 같은 게 가능한 이유가 바로 세션 관리 덕분입니다.

**4계층 - 전송 계층**

여기가 핵심입니다. TCP와 UDP가 동작하는 계층이거든요. 같은 컴퓨터에서 크롬, 카카오톡, 게임을 동시에 켜놔도 데이터가 안 섞이는 이유가 뭘까요? 포트 번호로 "80번은 웹, 443번은 HTTPS, 3306은 MySQL" 이렇게 구분하기 때문입니다. 데이터가 제대로 갔는지 확인하고, 잘못됐으면 다시 보내고, 네트워크가 막히면 속도를 조절하는 것도 다 이 계층의 몫이죠.

**3계층 - 네트워크 계층**

IP 주소를 보고 길을 찾습니다. 서울에서 부산까지 가는 경로가 여러 개일 때, 어느 길이 빠른지 판단해서 패킷을 보내주는 게 라우터의 역할이고, 이게 전부 네트워크 계층에서 일어나는 일입니다.

**2계층 - 데이터 링크 계층**

같은 네트워크 안에서 직접 붙어있는 장비들끼리 통신합니다. 우리 집 공유기에 노트북, 핸드폰, TV가 연결돼 있다면, 이 기기들은 MAC 주소로 서로를 식별하고 데이터를 주고받죠. 스위치가 이 계층에서 일합니다.

**1계층 - 물리 계층**

결국 0과 1은 전기 신호로 바뀌어야 케이블을 타고 갈 수 있습니다. 디지털 데이터를 물리적인 신호로, 또 그 반대로 바꿔주는 곳이 바로 여기죠.

---

## TCP vs UDP - 언제 뭘 써야 할까?

## TCP - 확실한 배송이 필요할 때

TCP는 연결부터 확실하게 합니다. 3-way handshake라고, 데이터 보내기 전에 세 번 악수하는 거죠.

1. 클라이언트: "보낼게요" (SYN)
2. 서버: "네, 받을 준비 됐어요. 저도 보낼 거 있어요" (SYN+ACK)
3. 클라이언트: "알겠습니다" (ACK)

이렇게 확인하고 나서야 데이터 전송을 시작합니다. 마치 전화 걸 때 "여보세요?" "네, 듣고 있습니다" "좋아요, 그럼 말씀드릴게요" 하는 것과 비슷하죠.

그리고 보낸 데이터마다 "잘 받았어요" 확인을 받습니다. 확인 못 받으면? 다시 보냅니다. 순서가 뒤바뀌어 도착하면? 다시 정렬합니다. 느리긴 해도 100% 정확하게 전달하는 게 TCP의 철학입니다.

은행 송금할 때 0 하나 빠지면 큰일 나잖아요? 그래서 HTTPS, 이메일, 파일 다운로드 같은 곳엔 무조건 TCP를 씁니다.

## UDP - 속도가 생명일 때

UDP는 정반대입니다. 연결? 그런 거 없습니다. 그냥 쏩니다. 받았는지 확인도 안 하고 계속 보내요.

유튜브 라이브 보다가 1초쯤 끊기면 어때요? 다시 재생되면 그만이잖아요. 그 1초 데이터 다시 받느라 5초 멈춰있는 것보다 훨씬 낫죠. 게임도 마찬가지입니다. 0.1초 빨리 반응하는 게 중요하지, 아까 날아간 패킷 하나 찾느라 렉 걸리면 안 되니까요.

DNS도 UDP를 씁니다. "naver.com 주소가 뭐야?" 물어보고 답 받으면 끝인데, 굳이 연결 설정할 필요 없잖아요?

**간단 비교**

- TCP: 20바이트 헤더 (무겁지만 안전)
- UDP: 8바이트 헤더 (가볍고 빠름)
- TCP: 신뢰성 필요한 곳
- UDP: 실시간 속도 중요한 곳

---

## IP 주소 - 네트워크의 주민등록번호

## IPv4가 부족해진 이유

192.168.0.1 같은 IPv4 주소는 43억 개까지 만들 수 있습니다. 많아 보이죠? 근데 전 세계 인구가 80억이고, 한 사람당 스마트폰, 노트북, 스마트워치, IoT 기기까지 생각하면 턱없이 부족합니다.

그래서 나온 게 IPv6입니다. 2001:0db8:85a3... 이런 식으로 엄청 길어졌지만, 거의 무한대에 가까운 주소를 만들 수 있죠. 문제는 아직도 대부분이 IPv4를 쓰고 있어서 전환이 더디다는 겁니다.

## 공인 IP와 사설 IP의 차이

공인 IP는 전 세계에서 하나뿐입니다. 우리 집 주소처럼 유일하죠. 하지만 사설 IP는 다릅니다.

집에서 공유기 쓰면 192.168.0.x 이런 주소 받잖아요? 옆집도 192.168.0.x를 쓸 수 있어요. 어차피 공유기 안에서만 쓰니까 겹쳐도 상관없거든요. 공유기가 NAT라는 기술로 "밖으로 나갈 때는 공인 IP, 안으로 들어올 때는 사설 IP"로 변환해줍니다.

## 서브넷 마스크 이해하기

192.168.1.0/24에서 /24가 뭘까요? 32비트 중 앞 24비트가 네트워크 주소라는 뜻입니다. 그럼 나머지 8비트(256개)로 호스트를 구분할 수 있죠.

회사에서 부서마다 네트워크를 나누고 싶을 때 이걸 씁니다. 영업팀은 192.168.1.x, 개발팀은 192.168.2.x 이런 식으로요.

---

## HTTP와 HTTPS

## HTTP - 웹의 기본 언어

브라우저가 서버랑 대화하는 방식입니다. 80번 포트를 쓰죠.

**두 가지 특징이 중요합니다**

비연결성: 페이지 하나 받으면 연결을 끊어버립니다. 비효율적 같지만, 동시에 수천 명이 접속하는 서버 입장에서는 훨씬 효율적이에요.

무상태성: 로그인했던 걸 기억 못 합니다. 그래서 쿠키랑 세션을 쓰는 거죠. 매번 "나 로그인한 사람이야" 하고 증명해야 합니다.

**주요 메서드**

- GET: 데이터 조회 (검색할 때)
- POST: 데이터 생성 (회원가입, 글쓰기)
- PUT/PATCH: 데이터 수정 (프로필 변경)
- DELETE: 데이터 삭제 (게시글 삭제)

**상태 코드**

- 200 OK: 성공
- 404 Not Found: 없는 페이지 (다들 한 번쯤 봤죠?)
- 500 Internal Server Error: 서버 터짐 (개발자 멘붕)

## HTTPS - 보안이 추가된 HTTP

HTTPS는 HTTP에 자물쇠를 채운 겁니다. 443번 포트를 씁니다.

SSL/TLS로 데이터를 암호화해서, 중간에 누가 가로채도 못 봅니다. 카페 와이파이 쓸 때 비밀번호 입력하는 게 무섭지 않은 이유가 HTTPS 덕분이죠.

요즘은 구글도 HTTPS 안 쓰는 사이트는 검색 순위를 낮춰버립니다. 보안이 선택이 아니라 필수가 된 시대입니다.

---

## DNS - 인터넷 전화번호부

## 왜 DNS가 필요할까?

223.130.200.107 이 주소 외울 수 있나요? 못 외웁니다. 근데 naver.com은 외우죠. 사람은 숫자보다 글자가 편하니까요.

DNS는 이 둘을 연결해주는 시스템입니다. 전화번호부처럼 "네이버 주소가 뭐더라?" 물어보면 "223.130.200.107이야" 하고 알려주는 거죠.

## 실제로 어떻게 작동할까?

naver.com을 주소창에 치면 이런 일이 벌어집니다.

1. 내 컴퓨터가 가까운 DNS 서버(보통 KT, SKT가 운영)에 물어봄
2. 캐시에 있으면 바로 답해줌 (0.001초)
3. 없으면 Root DNS → .com 담당 DNS → naver 담당 DNS 순서로 타고 올라감
4. 최종 IP 주소 받아서 접속
5. 다음번엔 빠르게 하려고 결과를 캐싱해둠

이 모든 과정이 0.1초도 안 걸립니다. 신기하죠?

## DNS 레코드 종류

- A 레코드: 도메인 → IPv4 (가장 많이 씀)
- AAAA 레코드: 도메인 → IPv6
- CNAME: 별칭 만들기 ([www.naver.com](http://www.naver.com/) → naver.com)
- MX: 메일 서버 주소

---

## 흐름제어와 혼잡제어

## 흐름제어 - 받는 쪽 속도 맞춰주기

보내는 쪽이 초당 1GB씩 쏘는데 받는 쪽이 100MB밖에 못 받으면 어떻게 될까요? 넘치는 데이터는 버려집니다. 그래서 받는 쪽 버퍼 크기를 보고 "지금 10개까지 보내도 돼"라고 윈도우 크기를 조절하는 게 Sliding Window 방식입니다.

Stop-and-Wait은 하나 보내고 ACK 기다리고, 또 하나 보내고 기다리고... 너무 비효율적이라 실제로는 안 씁니다.

## 혼잡제어 - 네트워크 막힐 때 대처법

고속도로 정체됐을 때 차를 더 보내봤자 더 막히잖아요? 네트워크도 마찬가지입니다.

**Slow Start**

처음엔 조심스럽게 1개, 2개, 4개, 8개... 이렇게 지수적으로 늘립니다. 잘 되면 빠르게 늘리고, 어느 정도 가면 천천히 늘리는 거죠. 임계값이 있어서, 그 값을 넘으면 1개씩만 조금씩 증가시킵니다.

**AIMD (덧셈 증가, 곱셈 감소)**

잘 되면 1개씩 더 보내고(+1), 막히면 절반으로 줄입니다(÷2). 그래프로 그리면 톱니 모양이 나오는데, 이게 TCP가 네트워크 상황에 맞춰 유연하게 대응하는 방식입니다.

**Fast Retransmit (빠른 재전송)**

같은 ACK가 3번 오면 "아, 중간에 하나 빠졌구나" 알아챕니다. 타임아웃 기다릴 것 없이 바로 재전송하죠. 몇 초 기다리는 것보다 훨씬 빠릅니다.

**Fast Recovery**

재전송한 후에 처음부터(Slow Start) 다시 시작하지 않고, 임계값부터 바로 시작합니다. 한 번 실수했다고 너무 조심스러워할 필요 없으니까요.

---

## 마무리

주소창에 naver.com 치고 엔터 누르면 이 모든 게 1초 안에 일어납니다.

1. DNS가 IP 주소 찾고
2. TCP가 3-way handshake로 연결 만들고
3. HTTP(S)로 "메인 페이지 주세요" 요청 보내고
4. 서버가 HTML 파일 보내주면
5. 데이터가 7계층을 타고 내려갔다 올라오고
6. 화면에 페이지가 뜹니다

각 계층이 독립적으로 동작하면서도 완벽하게 협력하는 시스템 그게 바로 컴퓨터 네트워크입니다.