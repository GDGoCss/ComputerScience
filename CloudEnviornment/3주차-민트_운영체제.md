# 페이지 교체 알고리즘 완벽 정리: LRU, FIFO, LFU, LFD, NUR

## 1. 페이지 교체 알고리즘의 개념
운영체제에서 **페이지 교체 알고리즘(Page Replacement Algorithm)**은 프로세스가 필요한 페이지가 메모리에 없는 경우, 즉 **페이지 폴트(Page Fault)**가 발생했을 때 어떤 페이지를 제거하고 새로운 페이지를 불러올지를 결정하는 기법이다.  

현대 운영체제는 **가상 메모리(Virtual Memory)**를 사용한다. 가상 메모리는 실제 물리 메모리보다 큰 주소 공간을 제공하지만, 실제로는 필요한 부분만 물리 메모리에 적재한다. 따라서 **메모리 크기보다 많은 페이지 요청**이 발생하면 불필요한 페이지를 교체해야 한다.  

이때 페이지 교체 알고리즘의 성능은 **페이지 폴트율(Page Fault Rate)**과 직결된다. 페이지 폴트가 발생할 때마다 디스크 I/O가 필요하므로, 알고리즘 선택은 시스템의 효율성과 사용자 경험에 큰 영향을 준다.  

### 지역성(Locality)의 원리
- **시간 지역성**: 최근에 사용된 페이지가 가까운 미래에 다시 사용될 가능성이 높음.  
- **공간 지역성**: 특정 메모리 위치가 접근되면 그 주변 위치도 곧 접근될 가능성이 높음.  

대부분의 페이지 교체 알고리즘은 이러한 **지역성(Locality)** 원리에 기반한다.

---

## 2. 오프라인 알고리즘 (LFD, Optimal)
### 개념
- **LFD(Optimal Replacement, OPT)**는 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 방식이다.  
- 이론적으로 가장 적은 페이지 폴트를 보장한다.

### 동작 방식
1. 페이지 폴트 발생  
2. 앞으로 가장 늦게 참조될 페이지 탐색  
3. 해당 페이지 제거 후 새로운 페이지 적재

### 특징
- 현실 시스템에서는 미래의 참조 패턴을 알 수 없으므로 구현 불가능하다.  
- 다른 알고리즘 성능을 평가하는 **Baseline(이론적 기준)**으로 사용된다.

### 면접 포인트
- Q: "OPT 알고리즘은 왜 실제 운영체제에서 쓰이지 않나요?"  
- A: "미래의 메모리 접근 패턴을 알 수 없기 때문에 실제 구현이 불가능합니다."

---

## 3. FIFO (First-In First-Out)
### 개념
- 가장 먼저 들어온 페이지를 가장 먼저 교체한다.  
- **큐(Queue)** 자료구조로 쉽게 구현된다.  
- 구현 단순성 때문에 운영체제 초창기에 많이 사용되었다.

### 동작 방식
1. 페이지 폴트 발생  
2. 가장 오래된 페이지(맨 앞에 들어온 페이지)를 제거  
3. 새로운 페이지 삽입

### 예시
페이지 프레임 크기 = 3, 요청 순서 = 7, 0, 1, 2, 0, 3, 0, 4

| 요청 | 메모리 상태 | 페이지 폴트 |
|------|-------------|-------------|
| 7    | [7]         | O |
| 0    | [7 0]       | O |
| 1    | [7 0 1]     | O |
| 2    | [0 1 2]     | O |
| 0    | [0 1 2]     | X |
| 3    | [1 2 3]     | O |
| 0    | [2 3 0]     | O |
| 4    | [3 0 4]     | O |

### 단점
- **Belady’s anomaly**: 프레임 수를 늘렸는데도 페이지 폴트가 증가하는 현상.  

### 실무 활용
- 단순한 임베디드 환경이나, 페이지 접근 패턴이 단순한 경우 제한적으로 사용.  

### 면접 포인트
- "FIFO에서 Belady anomaly가 발생하는 이유는 무엇인가요?"  

---

## 4. LRU (Least Recently Used)
### 개념
- 가장 오랫동안 사용되지 않은 페이지를 교체한다.  
- **시간 지역성(Locality of Time)**을 가장 잘 반영한 알고리즘이다.  

### 동작 방식
- 각 페이지의 최근 접근 시간을 기록하거나, 접근 시 순서를 관리한다.  
- 페이지 폴트 발생 시 가장 오래 사용되지 않은 페이지를 제거한다.

### 구현 방식
- **카운터 기반(Time Stamp)**: 접근할 때마다 시간 기록 → 가장 오래된 시간 제거  
- **스택 기반(Linked List)**: 접근 시 맨 위로 이동 → 가장 아래에 있는 페이지 제거  

### 예시
캐시 크기 = 3, 요청 순서 = A, B, C, A, D, B

| 요청 | 메모리 상태 | 페이지 폴트 |
|------|-------------|-------------|
| A    | [A]         | O |
| B    | [A B]       | O |
| C    | [A B C]     | O |
| A    | [A B C]     | X (A 최근 갱신) |
| D    | [B C D]     | O |
| B    | [C D B]     | O |

### 장점
- 실제 시스템에서 성능이 우수하다.  
- CPU 캐시, DB 버퍼 등에서 널리 사용된다.  

### 단점
- 구현 비용이 크다.  
- 하드웨어 차원에서는 직접 구현하기 어렵다.  

### 면접 포인트
- "LRU는 왜 실제에서 많이 쓰이나요?"  
  → 지역성(Locality) 원리를 잘 반영하기 때문.  
- "LRU의 구현 복잡도는?"  
  → 단순 구현 시 O(n), 해시+리스트 조합 시 O(1) 가능.  

---

## 5. NUR (Not Used Recently)
### 개념
- LRU의 근사 알고리즘.  
- **참조 비트(Reference Bit)**와 **수정 비트(Modified Bit)**를 사용한다.  
- 하드웨어 지원으로 효율적으로 구현 가능하다.  

### 동작 방식
- 페이지를 (참조 여부, 수정 여부)에 따라 4가지 클래스로 분류.  
  - (0,0): 최근 사용 X, 수정 X → 가장 먼저 교체  
  - (0,1): 최근 사용 X, 수정 O  
  - (1,0): 최근 사용 O, 수정 X  
  - (1,1): 최근 사용 O, 수정 O → 가장 마지막에 교체  

### 실무 활용
- 운영체제 커널 내부에서 자주 사용된다.  
- **Clock 알고리즘**이 대표적인 구현 방식.  

### 면접 포인트
- "NUR와 LRU의 차이는?"  
  → LRU는 정확하지만 비용이 크고, NUR는 근사치지만 효율적이다.  

---

## 6. LFU (Least Frequently Used)
### 개념
- 가장 적게 사용된 페이지를 교체한다.  
- 참조 횟수를 기반으로 교체 대상을 결정한다.  

### 동작 방식
1. 페이지 참조 시 카운터 증가  
2. 페이지 폴트 발생 시 가장 작은 카운터 값을 가진 페이지 제거  

### 예시
페이지 프레임 크기 = 3, 요청 순서 = A, B, A, C, A, B, D

| 요청 | 메모리 상태 | 카운트 | 페이지 폴트 |
|------|-------------|--------|-------------|
| A    | [A]         | A=1    | O |
| B    | [A B]       | A=1,B=1 | O |
| A    | [A B]       | A=2,B=1 | X |
| C    | [A B C]     | A=2,B=1,C=1 | O |
| A    | [A B C]     | A=3,B=1,C=1 | X |
| B    | [A B C]     | A=3,B=2,C=1 | X |
| D    | [A C D]     | A=3,C=1,D=1 | O (B 제거) |

### 문제점
- **초기 버스트 문제(Cold-start problem)**: 초기에 자주 사용된 페이지가 이후 사용되지 않아도 남아있음.  
- 해결법: 카운터 decay(시간이 지나면 참조 횟수 감소).  

### 실무 활용
- CDN, Redis 같은 캐시 시스템에서 제한적으로 사용.  
- LRU-K 등 변형 알고리즘으로 보완됨.  

### 면접 포인트
- "LRU와 LFU의 차이는?"  
  → LRU는 **최근성**, LFU는 **빈도**에 기반.  

---

## 7. 알고리즘 성능 비교 요약

| 알고리즘 | 기준 | 장점 | 단점 | 실무 활용 |
|----------|------|------|------|-----------|
| LFD(OPT) | 미래 참조 | 페이지 폴트 최소화 | 구현 불가 | 성능 비교 기준 |
| FIFO | 도착 순서 | 구현 단순 | Belady anomaly 발생 | 제한적 |
| LRU | 최근 사용 시각 | 실제 성능 우수 | 구현 복잡 | 널리 사용 |
| NUR | 참조/수정 비트 | 구현 효율적 | 근사치라 정확도 낮음 | 커널 내부 |
| LFU | 참조 횟수 | 적응성 높음 | 오래된 페이지 잔존 문제 | 제한적 |

---

## 8. 최종 요약
- **LFD(OPT)**: 이상적이지만 구현 불가  
- **FIFO**: 단순하지만 Belady anomaly 존재  
- **LRU**: 가장 현실적이고 널리 사용됨  
- **NUR**: LRU 근사치, 효율적 구현 가능  
- **LFU**: 참조 횟수 기반, 성능 문제 존재  

현실의 운영체제는 보통 **LRU 또는 그 변형(NUR, Clock 등)**을 기반으로 페이지 교체를 수행하며, 캐시나 DB 시스템에서도 LRU 계열이 사실상의 표준으로 자리잡고 있다.
