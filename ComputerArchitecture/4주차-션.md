# CSS 스터디- 컴퓨터구조



# 기본 구성 요소

CPU : 명령어 해석, 처리

RAM : 프로세스, 데이터 일시적 저장 → CPU의 빠른 접근 도움

보조기억장치 : 데이터 영구 저장

입출력장치 : 사용자 - 컴퓨터 간 인터페이스 역할.

시스템 버스 : 각 구성요소들이 데이터 주고받는 통로. (데이터 버스, 주소 버스, 제어 버스)

---

# 시스템 버스

주소 버스 : CPU가 접근할 메모리 or I/O 장치의 주소 전달 (단방향)

데이터 버스 : 실제 데이터 전송. (양방향)

제어 버스 : CPU와 장치 간에 제어-요청-상태 신호 전달 (대부분 단방향, 일부 양방향)

# CPU 명령어 처리 과정

CPU는 명령어 사이클 통해 명령어 처리.

1. 인출 (Fetch) : Program counter가 가리키는 메모리 주소에서 다음 실행할 명령어 가져와 IR에 저장 → PC는 다음 명령어 가리키도록 주소 증가.
2. 해독 (Decoder) : CU가 IR의 명령어 해석 → 수행할 연산 결정
3. 실행 (Execute) : ALU 연산, 메모리 접근, 레지스터 간 데이터 이동 등 수행.
4. 저장 (Write Back) : 실행 결과를 레지스터 또는 메모리에 저장.

---

# CPU 코어 수가 많아지면 성능 향상?

- 병렬 처리 가능성 : 프로그램이 멀티스레딩 지원해야 성능
- 소프트웨어 최적화 : 스케줄러의 효율적 작업 분배, 프로그램의 멀티코어 고려 설계 필요
- 암달의 법칙 : 프로그램 실행 시간 중 병렬화 가능한 비율이 성능 향상 한계 결정

---

# 레지스터 종류

- 프로그램 카운터 (PC) : 다음에 실행할 명령어의 메모리 주소를 저장.
- 명령어 레지스터 (IR) : 현재 실행 중인 명령어 저장.
- 메모리 주소 레지스터 (MAR) : CPU가 접근하려는 메모리 주소 저장.
- 메모리 버퍼 레지스터 (MBR/MDR) : 메모리에서 읽어온 데이터, 쓸 데이터 임시 저장.
- 상태 레지스터 (Status, Flag) : 연산 결과(양수,음수, 오버플로우) 상태 알려주는 flag들 저장 → if문 같은 조건 분기 처리에 사용.
- 범용 레지스터 : ALU 연산 결과, 메모리 주소, 단순 데이터 저장 등 다목적 레지스터.
- 누산기 (AC) : ALU 연산 결과를 일시적으로 저장하는 레지스터. (현대엔 범용 레지스터가 대체)

---

# RAM 종류

SRAM (Static RAM) :

- 정적 메모리.
- 전원 공급 중 데이터 유지.
- 속도 빠름, 가격 비쌈
- 회로가 복잡해 집적도 낮아 대용량으로 만들기 어려움 → CPU 내부의 캐시 메모리로 사용.

DRAM (Dynamic RAM):

- 주기적 재충전 필요.
- 속도 비교적 느림, 가격 저렴함.
- 구조가 단순해 집적도 높이기 쉬워 대용량 만들기 가능 → 메인 메모리로 사용

---

## HDD, SSD

### HDD :

디스크(플래터)를 물리적으로 회전시켜, 헤드가 데이터 읽고 씀

특징 : 대용량 저장 유리, 단가 낮음, 속도 느림, 소음/발열, 물리적 충격에 약함.

### SSD :

반도체 메모리(NAND 플래시)에 전기적으로 데이터를 저장.

장점 : 물리적 움직임 없기에 랜덤 접근 속도 빠름, 소음/발열 적음, 충격에 강함.

단점 :

- 용량 대비 가격 비쌈
- Cell의 수명에 따라 쓰기 횟수 제한 (웨어 레벨링으로 개선됨)

---

# 파이프라이닝

명령어 처리 단계를 분할해 병렬로 실행하는 기술.

ex) 명령어 A ‘실행 단계’ → 명령어 B ‘해독 단계’

장점 : 동일 시간 대비 더 많은 명령어 처리 → 전체 처리율 상승

단점 (해저드) :

- 데이터 해저드 : 이전 명령어의 결과가 필요한데 아직 계산 완료 전
- 제어 해저드 : 분기, jump 등으로 다음 실행 명령어 주소 예측 어려움
- 구조적 해저드 : 하드웨어 자원 동시에 필요시 충돌

---

# 가상메모리, 페이징

### 가상 메모리 :

실제 RAM 보다 큰 프로그램 실행 가능, 각 프로세스에 독립적 주소 공간 제공

### 페이징 :

가상 - 물리 메모리를 페이지라는 고정된 크기의 블록으로 나누어 관리하는 기법.

- 외부 단편화 해결하지만 내부 단편화 발생. (4KB 페이지에 1KB만 저장하면 낭비)

### 페이지 테이블 :

- 가상 주소 - 실제 물리 주소 매핑하는 정보 담고있는 테이블. MMU(Memory Management Unit)가 변환 담당.
- 서로다른 프로세스가 같은 가상 주소 사용 → 페이지 테이블 통해 서로 다른 물리 메모리 공간에 매핑. 충돌 X

### TLB (Translation Lookaside Buffer)

- 페이지 테이블의 일부를 캐싱하는 역할하는 고속 하드웨어.
- MMU가 가상 주소를 물리 주소로 변환시, 매번 RAM에 있는 페이지 테이블에 접근하면 느리기에 TLB를 먼저 확인하여 변환 속도 높임.

---

# RAID

RAID : 여러 하드디스크를 하나처럼 묶어 사용. 데이터 안정성, 성능 향상 목적

### RAID 0 (디스크 스트라이핑)

- 데이터를 여러 디스크에 분산 저장 → R/W 속도 매우 빠름.
- 하나의 디스크만 고장나도 모든 데이터 잃음 → 안정성 매우 낮음

### RAID 1 (미러링)

- 동일 데이터를 여러 디스크에 복제하여 저장 → 안정성, 무결성
- 쓰기 성능은 디스크 하나일 때와 비슷하나, 읽기 성능은 병렬로 읽어 향상.
- 사용 가능한 용량 = 전체 디스크 용량 / 2. 공간 효율성 낮음.

### RAID 4 (블럭 단위 스트라이핑 + 전용 패리티 디스크)

- 데이터는 블록 단위로 분산 저장, 패리티는 별도의 전용 디스크에 저장
- 단점 : 모든 쓰기 작업시 패리티 디스크에 접근됨 → 병목 현상으로 성능 저하

### RAID 5 (분산 패리티 블록)

- RAID 4 단점 개선. 패리티 정보를 여러 디스크에 분산 저장 → 하나 고장나도 남은 데이터와 패리티 이용해 복구 가능.
- 패리티 디스크의 병목 현상 해결해 쓰기 성능 향상
- 성능-안정성 적절히 타협되어 사용
- 최소 3개 디스크 필요

### RAID 6 (이중 분산 패리티)

- RAID 5 와 유사, 서로다른 두 개의 패리티 정보 분산 저장.
- 최대 2개의 디스크가 동시에 고장나도 데이터 복구 가능. 최소 4개 디스크 필요

### RAID 10 (1+0, 미러링된 스트라이프)

- 여러 디스크를 먼저 RAID 1로 묶어 미러링 그룹 생성 & 그룹들을 RAID 0 로 구성.
- RAID 0 속도 + RAID 1 안정성 모두 확보.
- 최소 4개의 디스크 필요.
- 가용 용량 절반으로 비용 높지만, 고성능+안정성 중요한 고성능 서버 환경에서 자주 사용.

---

# 캐시 메모리

CPU - RAM 속도 차이 완화

### 작동 :

- 캐시 히트 : 캐시에 있으면 즉시 사용
- 캐시 미스 : 캐시에 없으면 RAM에서 가져와 캐시에 저장.

### 지역성 :

- 시간적 지역성 : 최근 사용 데이터 다시 사용 가능성 높음
- 공간적 지역성 : 인접 데이터 사용 가능성 높음

### 캐시 계층 구조 :

갈수록 속도 저하, 용량 증가

- L1 캐시 : CPU 코어 내부에 존재.
- L2 캐시 : CPU 코어 내부or외부에 존재.
- L3 캐시 : 여러 코어가 공유.

### 캐시 매핑 방식

메모리에서 데이터 가져와 저장시 어느 위치에 저장할지 결정

직접 매핑 : 단순, 빠름, 충돌 빈번

완전 연관 매핑 : 유연, 충돌 적음, 복잡-비쌈

집합 연관 매핑 : 절충형, 실제 CPU에서 가장 많이 사용