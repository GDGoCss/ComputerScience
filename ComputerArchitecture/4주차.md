# 4주차

## 📋 목차

1. [컴퓨터의 기본 구성](https://www.notion.so/4-28afaec6a7b780a1a422e5184f5f62d1?pvs=21)
2. [CPU 구조](https://www.notion.so/4-28afaec6a7b780a1a422e5184f5f62d1?pvs=21)
3. [메모리 계층 구조](https://www.notion.so/4-28afaec6a7b780a1a422e5184f5f62d1?pvs=21)
4. [캐시 메모리](https://www.notion.so/4-28afaec6a7b780a1a422e5184f5f62d1?pvs=21)
5. [파이프라이닝](https://www.notion.so/4-28afaec6a7b780a1a422e5184f5f62d1?pvs=21)
6. [면접 핵심 질문](https://www.notion.so/4-28afaec6a7b780a1a422e5184f5f62d1?pvs=21)

---

## 1. 컴퓨터의 기본 구성

## 컴퓨터의 4대 핵심 부품

- **CPU**: 명령어 실행 및 연산 수행
- **주기억장치 (RAM)**: 실행 중인 프로그램과 데이터 임시 저장
- **보조기억장치 (SSD/HDD)**: 데이터 영구 저장
- **입출력장치**: 키보드, 마우스, 모니터 등 외부와 데이터 교환

## 폰 노이만 구조

**핵심 개념**: 명령어와 데이터를 같은 메모리에 저장하는 프로그램 내장 방식

**특징**: CPU와 메모리가 버스로 연결되어 순차적으로 명령어를 실행하며, 구조가 단순하지만 메모리 병목 현상이 발생할 수 있습니다.

---

## 2. CPU 구조

## CPU의 3대 구성 요소

**1. 연산장치 (ALU)**

산술 연산(덧셈, 뺄셈 등)과 논리 연산(AND, OR 등)을 수행하는 부분입니다.

**2. 제어장치 (CU)**

명령어를 해석하고 각 부품에 제어 신호를 보내 프로그램 실행을 제어합니다.

**3. 레지스터**

CPU 내부의 매우 빠른 임시 저장 공간입니다.

**주요 레지스터**:

- **프로그램 카운터 (PC)**: 다음 실행할 명령어의 주소 저장
- **명령어 레지스터 (IR)**: 현재 실행 중인 명령어 저장
- **누산기 (ACC)**: 연산 결과 임시 저장

## 명령어 사이클

CPU는 인출(Fetch) → 해독(Decode) → 실행(Execute) → 저장(Write-back) 단계를 반복하며 명령어를 처리합니다.

---

## 3. 메모리 계층 구조

## 메모리 계층의 필요성

속도가 빠른 메모리는 비싸고 용량이 작아, 속도와 용량, 비용의 균형을 맞추기 위해 계층 구조를 사용합니다.

## 메모리 계층

```
레지스터 (가장 빠름, 수백 Bytes)
    ↓
L1 캐시 (32-128KB)
    ↓
L2 캐시 (256KB-1MB)
    ↓
L3 캐시 (8-32MB)
    ↓
주기억장치 RAM (4-64GB)
    ↓
보조기억장치 SSD/HDD (가장 느림, TB 단위)
```

## RAM vs 보조기억장치

| 특성 | RAM (주기억장치) | SSD/HDD (보조기억장치) |
| --- | --- | --- |
| **속도** | 빠름 | 느림 |
| **휘발성** | 전원 꺼지면 삭제 | 영구 저장 |
| **용도** | 실행 중인 프로그램 | 파일 보관 |

메모리는 실행할 정보를 저장하고, 보조기억장치는 보관할 정보를 저장합니다.

---

## 4. 캐시 메모리

## 캐시가 필요한 이유

CPU와 RAM의 속도 차이를 줄여 성능을 향상시키기 위해 사용합니다.

**캐시 히트**: 필요한 데이터가 캐시에 있음 (빠름)

**캐시 미스**: 캐시에 없어서 RAM에서 가져옴 (느림)

## 지역성의 원리

캐시 적중률을 높이기 위한 핵심 원리입니다.

**시간적 지역성**

최근 사용한 데이터는 다시 사용될 가능성이 높습니다.

*예시*: 반복문의 변수, 함수 내 지역 변수

**공간적 지역성**

사용한 데이터 주변의 데이터도 곧 사용될 가능성이 높습니다.

*예시*: 배열의 순차 접근, 순차적 코드 실행

## 멀티코어와 캐시 일관성

멀티코어 시스템에서는 각 코어가 자신의 캐시를 가지므로, 같은 데이터를 여러 캐시가 보유할 때 일관성 문제가 발생할 수 있습니다. 이를 해결하기 위해 MESI 프로토콜 같은 캐시 일관성 프로토콜을 사용합니다.

---

## 5. 파이프라이닝

## 파이프라이닝이란

여러 명령어를 동시에 처리하여 CPU의 처리량을 높이는 기법입니다.

**5단계 파이프라인**:

```
IF (인출) → ID (해독) → EX (실행) → MEM (메모리 접근) → WB (저장)
```

명령어를 여러 단계로 나누어 각 단계가 동시에 다른 명령어를 처리함으로써, 한 클럭 사이클마다 하나의 명령어를 완료할 수 있습니다.

## 파이프라인 해저드

**1. 데이터 해저드**

이전 명령어의 결과가 필요한데 아직 준비되지 않은 경우 발생합니다.

**해결 방법**:

- **포워딩**: 결과를 바로 다음 단계로 전달
- **스톨(정지)**: 데이터가 준비될 때까지 대기
- **명령어 재배치**: 컴파일러가 독립적인 명령어를 중간에 배치

**2. 제어 해저드**

분기 명령어로 인해 다음 명령어 주소가 바뀌는 경우 발생합니다.

**해결 방법**:

- **분기 예측**: 분기 방향을 미리 예측 (현대 CPU는 90% 이상 정확도)
- **지연 분기**: 분기 명령 뒤에 독립적인 명령을 실행

## RISC vs CISC

| 특성 | RISC | CISC |
| --- | --- | --- |
| **명령어** | 단순, 고정 길이 | 복잡, 가변 길이 |
| **파이프라이닝** | 쉬움 | 어려움 |
| **예시** | ARM, MIPS | x86 (Intel, AMD) |
| **특징** | 전력 효율 좋음 | 코드 밀도 높음 |

ARM은 모바일 기기와 최근 M 시리즈 칩에 사용되고, x86은 데스크톱과 서버에 주로 사용됩니다.

---

## 6. 예상 면접 핵심 질문

## Q1. CPU의 구성 요소를 설명하세요.

**A**: CPU는 연산장치(ALU), 제어장치(CU), 레지스터로 구성됩니다. ALU는 산술 및 논리 연산을 수행하고, 제어장치는 명령어를 해석해 제어 신호를 생성하며, 레지스터는 CPU 내부의 빠른 임시 저장소로 PC, IR, ACC 등이 있습니다.

## Q2. 캐시 메모리가 왜 필요한가요?

**A**: CPU와 RAM의 속도 차이를 줄여 성능을 향상시키기 위해 필요합니다. 자주 사용되는 데이터를 빠른 캐시에 저장하여 접근 시간을 단축하고, 지역성의 원리를 활용하여 캐시 적중률을 높입니다.

## Q3. 지역성의 원리를 설명하세요.

**A**: 캐시의 효율을 높이기 위한 원리로, 시간적 지역성과 공간적 지역성이 있습니다. 시간적 지역성은 최근 사용한 데이터를 곧 다시 사용할 가능성이 높다는 것이고, 공간적 지역성은 사용한 데이터 근처의 데이터도 곧 사용될 가능성이 높다는 것입니다. 반복문 변수와 배열 순회가 각각의 예시입니다.

## Q4. 파이프라이닝이 무엇이고 왜 사용하나요?

**A**: 여러 명령어를 동시에 처리하여 CPU 처리량을 높이는 기법입니다. 명령어를 인출, 해독, 실행, 메모리 접근, 저장의 5단계로 나누고, 각 단계가 동시에 다른 명령어를 처리하여 한 클럭당 하나의 명령어를 완료할 수 있습니다.

## Q5. 파이프라이닝의 데이터 해저드를 어떻게 해결하나요?

**A**: 데이터 해저드는 이전 명령어의 결과가 필요한데 아직 준비되지 않아 발생합니다. 포워딩 기법으로 ALU 결과를 다음 단계로 직접 전달하거나, 스톨을 통해 데이터가 준비될 때까지 대기하거나, 컴파일러가 독립적인 명령어를 중간에 배치하여 해결합니다.

## Q6. RISC와 CISC의 차이점은 무엇인가요?

**A**: RISC는 단순하고 고정 길이의 명령어를 사용하여 파이프라이닝이 쉽고 전력 효율이 좋아 모바일 기기에 적합합니다. ARM이 대표적입니다. CISC는 복잡하고 가변 길이 명령어를 사용하여 코드 밀도가 높고, x86이 대표적으로 데스크톱과 서버에 사용됩니다.