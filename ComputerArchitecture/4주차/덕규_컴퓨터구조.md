# 컴퓨터 구조

## 컴퓨터 구조

- 개괄
    - 컴퓨터가 이해하는 정보
        1. 명령어
        2. 데이터
    - 네 가지 핵심 부품
        1. CPU
        2. Memory (RAM)
        3. 보조기억장치
        4. 입출력장치

- 핵심 부품
    - 메인보드
        - 모든 핵심 부품들을 연결한 메인보드
        - 칩셋을 통해 CPU, DRAM, Storage 등을 연결
    - CPU
        - 메모리에 저장된 명령어를 읽고(fetch), 해석(decode), 실행(execute)
        - ALU : 계산기 (산술논리연산장치)
        - Register : CPU 내부의 작은 저장장치
        - 제어장치 : 제어 신호를 내보내고, 명령어를 해석하는 장치
    - 시스템 버스
        - 버스 : 컴퓨터의 부품끼리 정보를 주고받는 일종의 통로
        - 시스템 버스는 컴퓨터의 핵심 부품을 연결하는 버스
            - 주소 버스 : CPU가 접근하고자 하는 메모리 주소 전달
            - 데이터 버스 : 실제 데이터를 주고받는 통로
            - 제어 버스 : 읽기/쓰기 등 제어신호를 주고받는 통로
    - 메모리
        - 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품
        - 프로그램이 실행되기 위해서는 메모리에 저장되어 있어야 한다
        - 메모리의 각 위치는 주소로 구분, CPU는 주소를 통해 접근
    - 보조기억장치
        - USB,SD카드,SSD,CD-ROM 등
        - 비싸고, 휘발성인 RAM을 대신하기 위한 저장장치
    - 입출력 장치
        - 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환가능한 부품

- 실행 과정 (CPU 사이클)
    1. Fetch(명령어 가져오기)
        : PC가 가리키는 주소에서 명령어를 메모리로부터 읽어옴
        : 읽은 명령어를 명령어 레지스터에 저장
    2. Decode(해석)
        : 제어장치가 명령어 레지스터에 저장된 명령어의 연산종류(opcode),피연산자 위치 해석
        : 필요한 경우 레지스터나 메모리에서 데이터를 불러올 준비
    3. Execute(실행)
        : ALU가 실제 연산 수행
        : 연산 결과는 레지스터나 메모리에 저장
    4. Memory(메모리 접근)
        : 캐시 접근/미스 시 상위 계층
    5. Write-back(결과 반영)
        : 결과를 목적 레지스터 or 메모리에 기록 or 다음 명령어 주소로 PC 갱신

- 폰 노이만 구조
    - 명령어와 데이터를 같은 메모리에 저장하는 프로그램 내장 방식
    - CPU와 메모리가 버스로 연결되어 순차적으로 명령어를 실행
    - 프로그램이 메모리에 저장됨


## 명령어 파이프라인

- 파이프라인
    1. Instruction Fetch
    2. Instruction Decode
    3. Execute Instruction
    4. Write back

- 파이프라인 위험 (파이프라인 해저드)
    : 명령어 파이프라인이 성능 향상에 실패하는 경우
    - 데이터 위험
        - 명령어 간의 의존성에 의해 야기
        - 모든 명령어를 동시에 처리할 수는 없음
        - 트랜잭션 처럼 이전 명령어가 다 실행되어야 비로소 실행할 수 있는 경우 존재 
    - 제어 위험
        - 프로그램 카운터의 갑작스러운 변화 (Jump or Interrupt와 같은 경우)
    - 구조적 위험
        - 서로 다른 명령어가 같은 CPU 부품을 쓰려고 하는 경우
        - 하드웨어 자원을 동시에 요구

- 각 위험 해결법
    - 데이터 위험
        - 포워딩, 스톨, 명령어 스케줄링
    - 제어 위험
        - 분기 예측, 지연 분기, 버블 삽입
    - 구조적 위험
        - 자원 복제, 스케줄링

- 슈퍼스칼라
    - CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조
        - 오늘날의 멀티 스레드 프로세서
        - 한 번에 여러 개의 명령어 실행 가능
    - 이론적으로는 파이프라인 개수에 비례해 처리속도 증가
        - 그러나 파이프라인 위험도 증가로 실제로 비례해서 증가하지는 않음


## 명령어 집합

- 명령어 집합 (ISA)
    - CPU가 이해할 수 있는 명령어들의 모음
        - 서로 다른 CPU에서 만들어놓은 명령어는 동작 안함
        - CPU가 x86 / ARM 이라면 다른 어셈블리어, 바이너리를 씀 
    - 명령어 집합에 따라 해석 방식, 레지스터, 파이프라이닝 등 다 달라짐

- CISC (Complex Instruction Set Computer)
    - x86
    - 복잡한 명령어 집합을 활용하는 컴퓨터
    - 가변길이 명령어를 활용
    - 명령어 파이프라이닝이 불리하다는 단점이 존재
        - 명령어가 워낙 복잡하고 다양한 기능을 제공
        - 명령어의 크기와 실행되는 시간이 일정하지 않음
        - 복잡한 명령어로 명령어 하나 실행하는 데 여러 클럭 주기 필요

- RISC (Reduced Instruction Set Computer)
    - ARM
    - 명령어의 종류가 적고, 짧음
    - 고정 길이 명령어 집합 활용
    - 명령어 파이프라이닝에 유리
        - 메모리 접근 최소화
        - 레지스터 많이 활용
    - CISC에 비해 더 많은 명령어를 활용

| 특성 | CISC | RISC |
| ------ | ----------------- | ----------------- |
| 명령어 | 복잡,가변길이 | 단순,고정길이 |
| 파이프라이닝 | 어려움 | 쉬움 |
| 특징 | 다양한 주소 지정 방식 | 적은 주소 지정 방식 |
| 클럭 | 다양한 클럭에 걸쳐 수행 | 1 클럭 내외로 명령어 수행 |
| 명령어 수 | 명령어 수가 적음 | 명령어 수가 많음 |


## 메모리 계층 구조

- 논리적 계층 구조
    - 응용 프로그램 계층
        : 사용자가 작성한 프로그램
    - 시스템 소프트웨어 계층 
        : 운영체제, 컴파일러, 어셈블러 등
    - 명령어 집합 구조 (ISA)
        : 소프트웨어와 하드웨어의 경계 역할
        : 하드웨어가 이해하는 언어의 규칙 집합
    - 마이크로아키텍처
        : ISA 구현위한 논리 설계 수준
    - 디지털 논리 회로
        : 게이트, 플립플롭 등 실제 회로 수준의 동작 원리

- 메모리 계층
    - 보조기억장치
    - 메모리
    - 캐시 메모리
    - 레지스터

- RAM (주기억장치)
    - 휘발성
    - DRAM
        - DYNAMIC RAM
        - 저장된 데이터가 동적으로 사라지는 RAM
        - 데이터 소멸을 막기 위해 주기적으로 재활성(다시 저장)
        - 일반적으로 메모리로 사용되는 RAM
    - SRAM
        - STATIC RAM
        - 저장된 데이터가 정적인(사라지지 않는) RAM
        - 전원이 연결되어있다면 저장된 데이터가 사라지지 않음 (아니면 없어짐)
        - 캐시 메모리에서 일반적으로 사용
    - SDRAM
        - Synchronous DRAM
        - 특별한 DRAM (플립플롭 구조)
        - 클럭 신호와 동기화된 DRAM (클럭 신호와 박자를 맞춰 움직임)
    - DDR SDRAM
        - Double Data Rate SDRAM
        - 특별한 SDRAM
        - 대중적으로 사용되는 RAM
        - 대역폭이 두배 더 커짐

- 캐시 메모리
    - CPU와 메모리 사이에 위치한 레지스터보다 용량이 크고 메모리보다는 빠른 SRAM 기반 저장장치
    - CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위해 탄생
    - 보조 기억장치 < 메모리 < 캐시 메모리 < 레지스터 순으로 속도 차이 발생
    - 계층적 캐시 메모리
        - L1 캐시 : CPU(코어) 내부에 존재
        - L2 캐시 : CPU(코어) 내부에 존재
        - L3 캐시 : CPU(코어) 외부에 존재

- 멀티코어 프로세서의 캐시 메모리
    - 코어마다 다른 캐시 사용
        - 그럼에도 불구하고 서로 다른 캐시의 일관성 맞춰줌
        - A코어에서 캐시를 변경하면 B코어도 캐시가 변경됨
    - 분리형 캐시
        - 명령어만을 담기 위한 캐시, 데이터를 담기 위한 캐시 따로 분리되기도 함

- 참조 지역성의 원리
    - 캐시 메모리는 메모리보다 욜양이 작음
    - 모든 내용을 저장하지 못함
    - 캐시 히트
        - 예측 성공
    - 캐시 미스
        - 예측 실패
    - 캐시 적중률
        - 캐시 히트 횟수 / 캐시 히트 횟수 + 캐시 미스 횟수
    - 공간 지역성
        - CPU가 접근한 메모리 공간 근처를 접근
        - 접근한 메모리 공간 근처에 몰려서 존재
    - 시간적 지역성
        - 최근에 참조된 주소의 내용 다시 참조

```
레지스터 (가장 빠름, 수백 Bytes)
    ↓
L1 캐시
    ↓
L2 캐시
    ↓
L3 캐시
    ↓
주기억장치 RAM
    ↓
보조기억장치 SSD/HDD
```

